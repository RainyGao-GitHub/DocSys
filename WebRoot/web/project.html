
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="renderer" content="webkit" />
    <link rel="shortcut icon"  href="static/SmartWiki/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Cheney" />
    <title>仓库详情-DocSys</title>
    <!-- Bootstrap -->
    <link href="static/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="static/font-awesome/css/font-awesome.min.css" rel="stylesheet">
    <link href="static/highlight/styles/default.css" rel="stylesheet">
    <link href="static/highlight/styles/zenburn.css" rel="stylesheet">
    <link href="static/fonts/font.css" rel="stylesheet">
    <link href="static/zTree/css/metroStyle/metroStyle.css" rel="stylesheet">
    <link href="static/nprogress/nprogress.css" rel="stylesheet">
    <link href="static/styles/kancloud.css" rel="stylesheet">
    <link href="static/bootstrapQ/qiao.css" rel="stylesheet">
    <link href="static/markdown/css/editormd.min.css" rel="stylesheet">
	<!-- context.js -->
	<link rel="stylesheet" type="text/css" href="static/ContextJS/css/demo.css">
	<link rel="stylesheet" type="text/css" href="static/ContextJS/css/context.standalone.css">
	<link rel="stylesheet" type="text/css" href="css/zjp-css.css">
		<!-- FreeTeam CSS-->
	<link rel="stylesheet" href="static/freeTeam/css/resetV2.css" type="text/css" media="screen" />
	<link rel="stylesheet" href="static/freeTeam/css/boot-css/bootstrap.custom.css" type="text/css" media="screen" /> 
	<link rel="stylesheet" type="text/css" href="css/style.css">
 	
 	<link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_768133_1t0u55lw1ri.css">
    <style type="text/css">
        .editormd-preview{
            left: 0 !important;
            right: auto !important;
        }

        .editormd .CodeMirror {
            float: right !important;
        }

        .editor-content table thead tr {
            color: #111111 !important;
        }
        .manual-mask{
	        position: absolute;
		    left: 0;
		    right: 0;
		    background: #fafafa;
		    top: 0;
		    bottom: 0;
		    z-index: 19;
		    opacity: 0.5;
		    display:none;
        }
        .closeBtn{
        	position:absolute;
        	top:20px;
        	right:15px;
        	font-size:13px;
        	cursor: pointer;
        }
        
        .uploadFileName{
        	cursor: text;
        }
        .reuploadAllBtn{
        	position:absolute;
        	top:15px;
        	right:50px;
        	font-size:13px;
        	cursor: pointer;
        }
        
        .reuploadBtn{
        	position:absolute;
        	top:0px;
        	right:50px;
        	font-size:13px;
        	cursor: pointer;
        }
    </style>


    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="static/bootstrap/js/html5shiv.min.js"></script>
    <script src="static/bootstrap/js/respond.min.js"></script>
    <![endif]-->
    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="static/scripts/jquery.min.js" type="text/javascript"></script>

</head>
<body>
<div class="m-manual manual-reader">

    <header class="navbar navbar-static-top manual-head" role="banner">
        <div class="container-fluid">
            <div class="navbar-header pull-left manual-title">
  				<a class="navbar-brand" href="/DocSystem/web/projects.html"><i class="fa fa-paper-plane"></i> DocSys</a>
                <span class="slidebar" id="slidebar">
                    <i class="fa fa-align-justify"></i>
                </span>
                <a  id="projectName" class="navbar-brand" href="#">仓库名</a>
                <span style="font-size: 12px;font-weight: 100;" class="projectVersion"></span>
            </div>

            <nav class="collapse navbar-collapse bs-navbar-collapse" role="navigation">
                <ul class="nav navbar-nav navbar-right">
				    <li id="userImgDiv" style="display:none"><img id="userImg" name="userImg" width="40px" height="40px" src="images/default/defaultHeadPic.png" onerror="UserImgErrHandler();" class="img-circle m5"/></li>
					<li id="userInfoDiv" style="display:none">
							<a href="" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false"><span>Rainy</span><span class="caret"></span></a>
							<ul class="dropdown-menu" role="menu">
								<li><a href="/DocSystem/web/myHostPage.html">个人中心</a></li>
								<li><a href="/DocSystem/web/reposManager.html">仓库管理</a></li>
								<li><a onclick="logout()">退出登录</a></li>
							</ul>
					</li>
					<li id="loginBtn">
                        <a onclick="showLoginPanel()"  title="用户登录">登录</a>
                    </li>
					<li>
						<button id="btnViewDoc" class="btn btn-default" type="button" onclick="previewDoc()" style="display:none">预览
	                    </button>
	                    <button id="btnExitEdit" class="btn btn-default" type="button" onclick="exitEdit()" style="display:none">退出编辑
	                   	</button>
	                    <button id="btnEditWiki" class="btn btn-default" type="button" onclick="lockAndEditWiki()" style="display:none">编辑
	                    </button>
	                    <button id="btnSaveWiki" class="btn btn-default" type="button" onclick="saveWiki()" style="display:none">保存
	                    </button>
					</li>
                </ul>
            </nav>
        </div>      
    </header>
    <article class="container-fluid manual-body">
        <div class="manual-left">
            <div class="manual-tab">
                <div class="tab-navg">
                    <span data-mode="view" class="navg-item main active"><i class="fa fa-align-justify"></i><b class="text">目录</b></span>
                    <!-- <span data-mode="view" class="navg-item lookPro"><i class="el-icon-search"></i><b class="text">进度查看</b></span> -->
                </div>
                <div id="treeBody" class="tab-wrap">
                    <div class="tab-item manual-catalog" id="uuz">

                        <div class="catalog-list read-book-preview" id="tree">
                            <ul id="doctree" class="ztree"></ul>
                        </div>

                    </div>
                </div>
                <div  class="uploadBox ">
		            <ul style="display:none" class="el-upload-list el-upload-list--text">
					</ul>
				</div>
            </div>

			<!-- 
            <div id="container" class="m-copyright">
                <p id="editTime">2017.7.7</p>   
            </div>
             -->
        </div>
        <div id="line" class="manual-line" ></div>
        <div class="second-table">
         	<div class="searchBox">
         		<div class="back">
         			<i class="backicon glyphicon glyphicon-arrow-left"></i>
         		</div>
         		<div class="content">
         			<i class="glyphicon glyphicon-search icon"></i>
         			<input placeholder="搜索..." type="text" />
         		</div>
         		<div class="dropdown">
         			<a class="selecticon glyphicon glyphicon-align-justify dropdown-toggle" data-toggle="dropdown" aria-expanded="false"></a>
         			<ul class="dropdown-menu" style="left:210px">
 		                    <li><a href="#">摘要</a>
 		                    </li>
 		                    <li><a  href="#">列表</a>
 		                    </li>
 		                    <li><a  href="#">创建时间</a>
 		                    </li>
 		                    <li><a  href="#">修改时间</a>
 		                    </li>
 		                    <li><a  href="#">文件名称</a>
 		                    </li>
 		                    <li><a  href="#">文件大小</a>
 		                    </li>
 		                </ul>
         		</div>
         	</div>
         	<div class="second-list">
         		<ul id="secondList">
         		</ul>
         	</div>
         </div>
        <div id="second-line" class="second-line" ></div>
        
        <div class="manual-right">
        <div class="filetitle"></div>
            <div class="manual-article">
                <div class="article-body editor-content"  id="doc" style="min-height: 650px">
                </div>
            </div>
        </div>
        <div class="manual-progress"><b class="progress-bar"></b></div>
    </article>
    <div class="manual-mask"></div>
</div>

<!-- 全屏遮罩 -->
<div id="statusDiv" style="display:none">
	<p>文件上传中...</p>
</div>

<!-- Share Modal -->
<div class="modal fade" id="shareProject" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="myModalLabel">项目分享</h4>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="col-sm-2 control-label">项目地址</label>
                    <div class="col-sm-10">
                        <input type="text" value="https://gpio.me/" class="form-control" onmouseover="this.select()" id="projectUrl" title="项目地址">
                    </div>
                    <div class="clearfix"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-default" data-dismiss="modal">关闭</button>
            </div>
        </div>
    </div>
</div>

<div id="new-doc" style="display:none">
    <form class="form" onkeydown="if(event.keyCode==13)return false;">
		<div class="modal-body">
		   <div class="form-group">
		       <label class="col-sm-2 control-label">名字</label>
		       <div class="col-sm-10">
	 	           <input class="form-control" type="text" name="name" style="width: 100%"/>
		       </div>
		       <div class="clearfix"></div>
		   </div>
		   <div class="form-group">
		       <label class="col-sm-2 control-label">描述</label>
		       <div class="col-sm-10">
	 	           <input class="form-control" type="text" name="content" style="width: 100%"/>
		       </div>
		       <div class="clearfix"></div>
		   </div>
		</div>
   	  	<div class="modal-footer">
	    	<div class="form-group">
	            <label class="col-sm-2 control-label">当前目录</label>
	            <div class="col-sm-10">
	                <input type="text" value="" class="form-control" name="remoteDir" title="目标地址">
	            </div>
	            <div class="clearfix"></div>
	        </div>
	    </div>
    </form>
</div>

<div id="copyConflictConfirmDialog" style="display:none">
    <form class="form" onkeydown="if(event.keyCode==13)return false;">
        <div class="form-group">
            <label>请输入新的文件名/目录名</label>
            <input class="form-control" type="text" name="newDocName" style="width: 100%"/>
        </div>
    </form>
</div>

<div id="uploadConfirmDialog" style="display:none">
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-2 control-label">文件：</label>
            <div class="col-sm-10">
                <input type="text" value="" class="form-control" name="uploadContent" title="上传文件">
            </div>
            <div class="clearfix"></div>
        </div>
    </div>
  	<div class="modal-footer">
    	<div class="form-group">
            <label class="col-sm-2 control-label">上传至：</label>
            <div class="col-sm-10">
                <input type="text" value="" class="form-control" name="remoteDir" title="目标地址">
            </div>
            <div class="clearfix"></div>
        </div>
    </div>
</div>

<div id="fileCoverConfirmDialog" style="display:none">
    <div class="modal-body">
        <div class="form-group">
            <label class="col-sm-2 control-label">文件：</label>
            <div class="col-sm-10">
                <input type="text" value="" class="form-control" name="uploadContent" title="上传文件">
            </div>
            <div class="clearfix"></div>
        </div>
    </div>
</div>

<!-- multiple file and dir upload triger div -->
<div style="display:none">
	<input id="uploadFiles" name="uploadFiles" type="file" class="fLeft" onchange="selectUploadConfirm(event)" style="margin-top: 90px;" multiple="multiple"/>
	<input id="uploadDir" type="file" onchange="selectUploadConfirm(event)" webkitdirectory>

</div>
<textarea cols="20" rows="10" id="copiedText"></textarea>
	
<!-- single file upload form -->
<div style="display:none">
	<form id="FileUploadForm" action="/DocSystem/Doc/uploadDoc.do" method="post" enctype="multipart/form-data">  
		<input id="uploadFile" name="uploadFile" type="file" class="fLeft" style="margin-top: 90px;" multiple="multiple"/>
		<input type="text" value="0" id="reposId" name="reposId" title="所在仓库"/>
		<input type="text" value="0" id="parentId" name="parentId" title="父节点"/>	
		<input type="text" value="-1" id="docId" name="docId" title="文件节点"/>
		<input type="text" value="1" id="uploadType" name="uploadType" title="上传类型：1文件 2文件夹"/>
	</form>
</div>
           
<!-- Include all compiled plugins (below), or include individual file	s as needed -->
<script type="text/javascript" src="static/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="static/layer/layer.js"></script>
<script type="text/javascript" src="static/nprogress/nprogress.js"></script>
<script type="text/javascript" src="static/highlight/highlight.js"></script>
<script type="text/javascript" src="static/highlight/highlightjs-line-numbers.min.js"></script>
<script type="text/javascript" src="static/bootstrapQ/qiao.js"></script>
<script type="application/javascript" src="static/markdown/lib/raphael.min.js"></script>
<script type="application/javascript" src="static/seajs/sea.js"></script>
<script type="application/javascript" src="static/scripts/jsonEscape.js"></script>
<!-- zTree -->
<script type="text/javascript" src="static/zTree/js/jquery.ztree.all.min.js"></script>
<!-- For ajax form submit -->
<script  type="text/javascript" src="static/scripts/jquery.form.js"></script>
<!-- context。js -->
<script type="text/javascript" src="static/ContextJS/js/context.js"></script>
<!-- <script  type="text/javascript" src="static/ContextJS/js/jquery.min.js"></script>
 -->
<script type="text/javascript" src="js/fileReader.js"></script>
<script type="text/javascript" src="static/js-spark-md5/spark-md5.min.js"></script>
<script type="text/javascript">
	//初始化全局变量 //Repos Info
	var gReposId;
	var gReposInfo = [];
	var gReposType = 1; //默认是普通文件系统
	var gReposName = "";
	var gReposCreateTime = "";
	//Doc Info
	var gDocId;
	var gDocContent;
	var gEdit; 
	
	//通用函数接口
	function showErrorMessage($msg) {
    	qiao.bs.alert($msg);
	}
	
	function closeBootstrapDialog(id){ 
		$("#"+id + "div").remove();	//删除全屏遮罩
		$("#"+id).remove();	//删除对话框
	}

	function getDeleteNodes()
	{
		var deleteNodes = [];
		
		var treeObj = $.fn.zTree.getZTreeObj("doctree");
		var selectedNodes = treeObj.getSelectedNodes();
		if(selectedNodes == null || selectedNodes.length < 2)
		{
			console.log("selectedNodes",selectedNodes);
			if(curRightClickedTreeNode != null)
			{
				deleteNodes.push(curRightClickedTreeNode);
			}
		}
		else
		{
			deleteNodes = selectedNodes;
		}
		
		return deleteNodes;
	}
	
	function DoDelete(treeNodes)
	{
		if(treeNodes == null || treeNodes.length < 1)
		{
			bootStrapQ.alert("清选择需要删除的文件或目录");
		}
		else
		{
			var treeNode = treeNodes[0];
			var msg =  "是否删除文件 " + treeNode.name;
			if(treeNodes.length > 1)
		  	{
				msg =  "是否删除 " + treeNode.name + "等" + treeNodes.length  +"文件";	
		  	}
			else
			{
				if(treeNode.type == 2)
				{
					msg =  "是否删除整个目录 " + treeNode.name;	
				}
			}
			
			bootstrapQ.confirm({
				id: "deleteConfirm",
				title: "删除确认",
				msg : msg,
				},function () {
			    	//alert("点击了确定");
					DocDelete.deleteDocs(treeNodes);
			    	return true;   
			 	});
		}
	}

	function getCopiedNodes()
	{
		var treeNodes = [];
		
		var treeObj = $.fn.zTree.getZTreeObj("doctree");
		var selectedNodes = treeObj.getSelectedNodes();
		if(selectedNodes == null || selectedNodes.length < 2)
		{
			console.log("selectedNodes",selectedNodes);
			if(curRightClickedTreeNode != null)
			{
				treeNodes.push(curRightClickedTreeNode);
			}
		}
		else
		{
			treeNodes = selectedNodes;
		}
		
		return treeNodes;
	}

	function DoPaste(treeNodes,dstParentNode)
	{
		console.log("DoPaste()",treeNodes,dstParentNode);
		if(treeNodes == null || treeNodes.length < 1)
		{
			console.log("DoPaste nothing was copied");
			return;	
		}
		
		console.log("StartCopy");
		DocCopy.copyDocs(treeNodes,dstParentNode,gReposId);
	}

	function copyDocName(){
		var id = 0;
		if(curRightClickedTreeNode == null)
		{
			bootstrapQ.alert("请选择文件或目录");
			return false;
		}
		id = curRightClickedTreeNode.id;
		var docName = curRightClickedTreeNode.name;
		console.log("copiedDocName:" + docName);
		
		//window.clipboardData.setData("Text",url);	//剪贴板存在兼容性问题
		var obj=document.getElementById("copiedText");
		obj.value=docName;	//修改其中的值
		obj.select(); // 选择对象
		document.execCommand("Copy"); // 执行浏览器复制命令
        // 普通消息提示条
		bootstrapQ.msg({
					msg : '复制成功！',
					type : 'success',
					time : 1000,
		});
	}
	
	function copyDocPath(){
		var id = 0;
		if(curRightClickedTreeNode == null)
		{
			bootstrapQ.alert("请选择文件或目录");
			return false;
		}
		id = curRightClickedTreeNode.id;
		var docPath = getNodePath(curRightClickedTreeNode);
		console.log("docPath:" + docPath);
		
		//window.clipboardData.setData("Text",url);	//剪贴板存在兼容性问题
		var obj=document.getElementById("copiedText");
		obj.value=docPath;	//修改其中的值
		obj.select(); // 选择对象
		document.execCommand("Copy"); // 执行浏览器复制命令
        // 普通消息提示条
		bootstrapQ.msg({
					msg : '复制成功！',
					type : 'success',
					time : 1000,
		});
	}
	
	function copyUrl(){
		var id = 0;
		if(curRightClickedTreeNode == null)
		{
			bootstrapQ.alert("请选择文件或目录");
			return false;
		}
		id = curRightClickedTreeNode.id;
		var vid = gReposId;
		var href = "/DocSystem/web/project.html?vid="+vid+"&doc="+id;
		console.log(href);
		var host = window.location.host;	//域名带端口
		//var host2=document.domain; 			//域名不带端口
		//var url = window.location.href;		//全路径
		console.log(host);
		//console.log(host2);
		//console.log(url);
		var url = host+href;
		console.log(url);
		
		//window.clipboardData.setData("Text",url);	//剪贴板存在兼容性问题
		var obj=document.getElementById("copiedText");
		obj.value=url;	//修改其中的值
		obj.select(); // 选择对象
		document.execCommand("Copy"); // 执行浏览器复制命令
        // 普通消息提示条
		bootstrapQ.msg({
					msg : '复制成功！',
					type : 'success',
					time : 1000,
		});
	}
	
	
	/*文件上传实现*/
	function download(){
		
		var id = 0;
		if(curRightClickedTreeNode == null)
		{
			bootstrapQ.alert("请选择需要下载的文件或目录");
			return false;
		}
		id = curRightClickedTreeNode.id;
		var name = curRightClickedTreeNode.name;
		if(confirm("是否下载文件：" + name) == false)
		{
			return;
		}

		window.location.href = "/DocSystem/Doc/doGet.do?id="+id;

   		//download Doc
        /*$.ajax({
            url : "/DocSystem/Doc/downloadDoc.do",	//文件或目录下载，ret.data中包含了下载路径等信息
            type : "post",
            dataType : "json",
            data : {
                id : id,
            },
            success : function (ret) {
                console.log(ret);
                if( "ok" == ret.status ){
                  	downloadUrl = ret.data.path;
                  	alert(downloadUrl);
    				window.location.href = "/DocSystem" + downloadUrl;
                }
            },
            error : function () {
                showErrorMessage('服务器异常');
                $btn.button('reset');
            }
        });*/
	}
    
    /*文件上传实现*/
	//文件上传入口
	function uploadFiles(){
	
	    $("#uploadType").val(1); //文件	
	    return $("#uploadFiles").click();
	}
	
	//文件夹上传入口
	function uploadDir(){
		$("#uploadType").val(2);
	    return $("#uploadDir").click();
	}
	
	//get the filename 
	function getFileName(o){
	    var pos=o.lastIndexOf("\\");
	    return o.substring(pos+1);  
	}

	//upload file confirm dialog
	function selectUploadConfirm(e)
	{
		console.log("selectUploadConfirm",e);
	    var entrys = e.target.files;
	    
	  	//if curentRightClickedTreeNode is not parent node, set the newNode's parent to curentRightClickedTreeNode's parent node
		var parentNode = curRightClickedTreeNode;
		if(curRightClickedTreeNode && curRightClickedTreeNode.isParent === false)
		{
			parentNode = curRightClickedTreeNode.getParentNode();
		}
		
		checkUserUploadRight(entrys,parentNode,uploadConfirm);		
	    return true;
	}
	
	function dragUploadConfirm(e)
	{
		console.log("dragUploadConfirm",e);
        
		//getFileList
        var entrys = getFileList(e);
        console.log("entrys",entrys);
        
	  	//get the parentNode
	  	console.log(e.target);
        if(e.target.tagName=="SPAN"){
        	e.target.parentNode.click();
        }
	  	var treeObj = $.fn.zTree.getZTreeObj("doctree");
		var selectedNode = treeObj.getSelectedNodes()[0];
		console.log(selectedNode);
		var parentNode = selectedNode;
		if(selectedNode && selectedNode.isParent === false)
		{	
			console.log("selectedNode:" + selectedNode.name);
			parentNode = selectedNode.getParentNode();
		}
		
		//用户确认上传
		checkUserUploadRight(entrys,parentNode,uploadConfirm);
	    return true;
	}
	
	//获取用户的权限
	function checkUserUploadRight(files,parentNode,callback)
	{
		//get Pid
		var pid = 0;
		if(parentNode)
		{
			pid = parentNode.id;
		}
		var vid = gReposId;
		var remoteDir = getNodePath(parentNode);	//only for display
		
		$.ajax({
			url : "/DocSystem/Repos/getUserDocAuth.do",
			type : "post",
			dataType : "json",
			data : {
				docId : pid,
				reposId : vid
			},
			success : function (ret){
				if( "ok" == ret.status){
					var docAuth = ret.data;
					console.log(docAuth);
					if(docAuth.addEn == 1 || docAuth.editEn == 1)
					{
						callback && callback(files,parentNode);
					}
					else
					{
						showErrorMessage("您没有目录 "+remoteDir+" 的新增或修改权限");
					}
					return;
 				}
				else
				{
					showErrorMessage("Error:",ret.msgInfo);
					return;
				}
			},
			error : function () {
				showErrorMessage("获取用户权限异常");
				return;
			}
		});
	}
	
	//drag upload file confirm dialog（拖拽上传的确认对话框）
	function uploadConfirm(files,parentNode)
	{	
		console.log("uploadConfirm()");
		//build upload confirm text
	    if(files.length > 0)
	   	{
	    	console.log("files.length:" + files.length);
	    	for( var i = 0 ; i < files.length ; i++ )
	    	{  
	    		firstFile = files[i];
	    	   	if(typeof firstFile == 'object')
	    	   	{
	    	   		relativePath = firstFile.webkitRelativePath;	//获取第一个文件的相对路径
	    	   		console.log("firstFile relativePath:"+firstFile.webkitRelativePath);
	    	   		break;
	    	   	}
	    	   	else
	    	   	{
	    	   		//This is something else 
	    	   		//console.log("it is not a file");
	    	   	}
	    	}
	    	
	    }
	    else
	   	{
	   		bootstrapQ.alert("请选择文件");
	      	return false;
	   	}  
		
		var fileName = firstFile.name;
	    console.log("firstFile:"+fileName);
	  	
	  	var uploadContent = fileName;
	  	//if(relativePath)
	  	//{
	  	//	uploadContent = relativePath;
	  	//}
	  	if(files.length > 1)
	  	{
	  		uploadContent = uploadContent + " 等" + files.length + "个文件";
	  	}
	  	
	  	//get the parentNode
	  	var parentId = 0;
		if(parentNode&&parentNode.type=="2"){
			parentId=parentNode.id;	
		}else{
			if(parentNode&&parentNode.getParentNode()){
				parentNode=parentNode.getParentNode();
				parentId=parentNode.id;
				console.log(parentId);
			}else{
				parentNode=null;
			}
		}
		if(parentNode && parentNode.id)
		{
			parentId = parentNode.id;
		}
		var vid = gReposId;
		
		var remoteDir = getNodePath(parentNode);	//only for display
		
	    qiao.bs.dialog({
	        id: "dialog-uploadDialog",
	        url: '#uploadConfirmDialog',
	        title: '文件上传',
	        okbtn: "开始上传",
	        callback: function () {
	            setTimeout(function () {
	                //alert("it works now");
	                //set the show name for uploadFiles
	                //$("#uploadContent").val(uploadContent);
	                $("#dialog-uploadDialog input[name='uploadContent']").val(uploadContent);
	                //set the show name for destiontion remote directory
	                $("#dialog-uploadDialog input[name='remoteDir']").val(remoteDir);                
	                 
	            },100);
	        }
	    },function () {
	    	//alert("点击了确定");
			//开始上传
			DocUpload.uploadDocs(files,parentNode,parentId,vid);
	    	return true;   
	    });
		return true;
	}

	//DocUpload类
    var DocUpload = (function () {
        /*全局变量*/
        var isUploading = false;	//文件上传中标记
        var stopUploadFlag = false;	//结束上传
        var drawedNum = 0; //已绘制的进度条个数
        var uploadedNum = 0; //已上传个数
        var successNum = 0;	//成功上传个数
		var failNum = 0; //上传失败个数
		var totalSize = 0;	//总大小
        var uploadedSize = 0; //已上传大小：uploadedFileSize + 上传中文件的loadedSize
		var uploadedFileSize = 0; //已完成上传的文件大小
		var preUploadSize = 0; //上次的已上传大小
		var uploadTime = 0; //当前上传时间
        var preUploadTime = 0; //上次的上传时间
        var uploadStartTime = 0;//上传开始时间，用于计算已用时间
        var uploadSpeed = 1000;	//1k/s
        
        /*uploadDoc conditions 用于指示当前的上传文件及上传状态*/
        var index = 0; //当前操作的索引
        var totalNum = 0; 
 		var SubContextList = []; //文件上传上下文List，用于记录单个文件的上传情况，在开始上传的时候初始化
        var vid = 0;
 		
        //状态机变量，用于实现异步对话框的实现
        var fileCoverConfirmSet = 0; //0：文件已存在时弹出确认窗口，1：文件已存在直接覆盖，2：文件已存在跳过
        var uploadErrorConfirmSet = 0; //0:上传错误时弹出确认是否继续上传窗口，1：上传错误时继续上传后续文件， 2：上传错误时停止整个上传		
        
        //vars for reupload
        var reuploadFlag = false; //false: 正常上传  true: 重传
        var reuploadCount = 0; 
        var reuploadTotalNum = 0;
        var reuploadFailNum = 0;
        var reuploadSuccessNum = 0;
        var reuploadedNum = 0;
        var reuploadList = []; //重传列表，保存的是SubContext的index
        var reuploadIndex = 0;	//This is for reupload, the index should be reuploadList[reuploadIndex]
        
        //标准Java成员操作接口
        function getUploadStatus()
        {
        	var uploadStatus = "idle";
        	if(isUploading == true)
        	{
        		uploadStatus = "busy";
        	}
        	console.log("uploadStatus: " + uploadStatus);
        	return uploadStatus;
        }
      	
      	//设置进度条的上传取消按键的接口,this function has performance issue, so it will not be used
    	function itemStopUploadDelegate()
    	{
    		console.log("itemStopUploadDelegate");
      		var len = SubContextList.length;
      		if(len > 0)
      		{
      			for(var i=0;i<len;i++)
    			{
      				//设置每个上传文件的stopUpload处理函数
    	    		$('.file'+i).delegate('.stopUpload','click',function(){
    					//isUploading=false
    					//console.log($(this).attr('value'));
    					var index = $(this).attr('value');	//value 不是i的原生属性，所以不能用value
    					console.log("stopUpload " + index);
    					DocUpload.stopUpload(index);
    				});
    			}
      		}
    	}
    	
		//多文件Upload接口
		function uploadDocs(files,parentNode,parentId,vid)	//多文件上传函数
		{
			console.log("uploadDocs()");
			//console.log(files);
			if(files.length <= 0)
			{
				//alert("没有需要上传的文件!");
				showErrorMessage("没有需要上传的文件!");
				return;
			}
				
			if(isUploading == true)
			{
				DocUploadAppend(files,parentNode,parentId,vid);
			}
			else
			{
				//初始化文件上传参数
				DocUploadInit(files,parentNode,parentId,vid);
				
				uploadTime = new Date().getTime();	//初始化上传时间
				uploadStartTime = uploadTime;
				preUploadTime = uploadTime;
				//启动第一个Doc的Upload操作      		
				uploadDoc();	//start upload
			}
		}
		
		//初始化DocUpload设置
      	function DocUploadInit(files,parentNode,parentId,vid)	//多文件移动函数
		{
			console.log("DocUploadInit");
			//设置为正在上传，避免被其他上传中断
			isUploading = true;
			
			reuploadFlag = false; //false: 正常上传  true: 重传
	        
			//清空所有全局变量
			stopUploadFlag = false;
			fileCoverConfirmSet = 0;
			uploadErrorConfirmSet = 0;
			uploadedNum = 0;
			successNum = 0;
			failNum = 0;
			drawedNum =0;
			//清空上下文列表
			SubContextList = [];
			FailList = [];
			
			//Set the Index
			index = 0;
			
			//Build SubContextList and get total Size
			totalSize = buildSubContextList(files,parentNode,parentId,vid,SubContextList);
			
			//Set upload total file Num
			totalNum = 0;
			if(files && files.length)
			{
				totalNum = files.length;
			}
			console.log("文件总的个数为："+totalNum + " 文件总的大小为："+totalSize);
			
			//Draw UploadItems by Go through the SubContextList
			preUploadSize = 0;
			uploadedFileSize = 0;
			if(SubContextList.length > 0)
		   	{
		   		//初始化上传进度显示
				var str="<div><span class='upload-list-title'>正在上传  " +index +" / " + totalNum +"</span><span class='reuploadAllBtn' onclick='reuploadFailDocs()'>全部重传 </span><i class='el-icon-close closeBtn'></i></div>";
				str +="<div id='uploadedFileList' class='uploadedFileList'></div>";
				$(".el-upload-list").show();
				$('.el-upload-list').html(str);
				checkAndDrawUploadItems(SubContextList);
		   	}
      	}
      	
      	//增加上传文件
      	function DocUploadAppend(files,parentNode,parentId,vid)	//多文件移动函数
		{
			console.log("DocUploadAppend");
			
			
			//Go through files, and add files to SubContextList
			var totSize = buildSubContextList(files,parentNode,parentId,vid,SubContextList);
			totalSize += totSize;			
			
			var totNum = 0;
			if(files && files.length)
			{
				totNum = files.length;
			}
			totalNum += totNum;
			
			showUploadingInfo();
			
			console.log("文件总的个数为："+totalNum + " 文件总的大小为："+totalSize);
			checkAndDrawUploadItems(SubContextList);
      	}
      	
      	//这是一个递归调用函数，递归遍历所有目录，并将文件加入到SubContextList中
		function buildSubContextList(files,parentNode,parentId,vid,SubContextList)
		{
			var totSize = 0;
			console.log("buildSubContextList()");
			if(files.length > 0)
	   		{
	    		console.log("files.length:" + files.length);
	    		for( var i = 0 ; i < files.length ; i++ )
	    		{
	    			var file = files[i];
	    	   		if(typeof file == 'object')
	    	   		{
	    	   		   	var SubContext ={};
	    	   		   	//Basic Info
	    	   		   	SubContext.file = file;
	    	   		   	SubContext.parentNode = parentNode;
	    	   		   	SubContext.parentId = parentId;
	    	   		   	SubContext.vid = vid;
	    	   		   	
			    		SubContext.docId = -1; //-1: 新增  
			    		
	    	   		   	//advanced Info
	    	   		   	SubContext.type = 1;	
			    	   	SubContext.size = file.size;
	    	   		   	SubContext.name = file.name;
				    	SubContext.relativePath = file.webkitRelativePath;
				    	if(file.fullPath)
				    	{
				    		SubContext.relativePath = file.fullPath;
				    	}
				    	
				    	//Status Info
			    		SubContext.index = i;
			    	   	SubContext.state = 0;	//未开始上传
			    	   	SubContext.status = "待上传";	//未开始上传
			    	   	
			    	   	//checkSum Init
			    	   	SubContext.checkSumState = 0;
			    	   	SubContext.checkSum = "";
			    	   	
			    	   	//StateMachine SMMain\SMSub
			    	   	SubContext.SMState = "init";	//uploadDoc状态机的主状态
			    	   	SubContext.SMSubState = 0;	//uploadDoc状态机的子状态
			    	   	
			    	   	//分片上传状态 
			    	   	SubContext.cutFileState = 0;
			    	   	SubContext.chunked = false;
			    	   	
			    	   	SubContext.fileCoverConfirmSet = 0;	//默认碰到已存在文件需要用户确认是否覆盖
			    		SubContext.uploadErrorConfirmSet = 0;	//默认碰到错误需要用户确认
			    		SubContext.stopUploadFlag = false; //停止上传标记未false
			      								    	   	
			    	   	//Push the SubContext
			    	   	SubContextList.push(SubContext);
			    	   	totSize += file.size;
	    	   		}
	    	   	}
	    	}
	    	//console.log(SubContextList);
	    	console.log("buildSubContextList() totSize:" + totSize);
	    	return totSize;
	   	}
      	
      	function getFileShowSize(fileSize)
      	{
			var showSize = fileSize;
			var units = "B";	//速度单位
			if((showSize/1024)>1)
			{
				showSize = showSize/1024;
				units = "K";
				if((showSize/1024)>1)
				{
					showSize = showSize/1024;
					units = "M";
					if((showSize/1024)>1)
					{
						showSize = showSize/1024;
						units = "G";						
					}
				}
			}
			result =  "" + showSize + units;
			console.log("getFileSize() showSize:" + result);
			return result;
      	}
      	
      	//初始化上传文件的SubContext,并绘制对应的进度条
      	function checkAndDrawUploadItems(SubContextList)
      	{
      			//Check if all items drawed
      			if(drawedNum >= totalNum)
      			{
      				//console.log("druawUploadItems() all items drawed");
      				return;
      			}
      			
      			//the drawedNum ahead of index less than 100, do draw the doc progress
      			if((drawedNum - index) > 100)
      			{
      			    console.log("druawUploadItems() drawedNum:" + drawedNum + " index:" + index);
      				return;
      			}
      			
      			//Prepare to drawed
      			var startIndex = drawedNum;
      			var endIndex = totalNum;
      			if((totalNum -drawedNum) > 200)	//每次最多绘制200个
      			{
      				endIndex = drawedNum + 200;
      			}
      			var str = "";
      			for( var i = startIndex ; i < endIndex ; i++ )
		    	{	
		    		//console.log("index:" + i);
		    		var SubContext = SubContextList[i];
		    		SubContext.showSize = getFileShowSize(SubContext.size);
		    		//console.log(SubContext);
					str+="<li class='el-upload-list__item file"+i+" is-uploading' value="+i+">"+
		    				"<a class='el-upload-list__item-name uploadFileName'><i class='el-icon-document'></i><span class='uploadFileName' >"+SubContext.name+"</span></a>"+
		    				"<a class='reuploadBtn reupload"+i+"' onclick='reuploadFailDocs("+i+")'>重传 </a>"+
		    				"<label class='el-upload-list__item-status-label'><i class='el-icon-upload-success el-icon-circle-check'></i></label>"+
		    				"<i class='el-icon-close stopUpload'  value="+i+" onclick='stopUpload("+i+")'></i>"+
		    				"<div class='el-progress el-progress--line'>"+
		    					"<div class='el-progress-bar'>"+
		    						"<div class='el-progress-bar__outer' >"+
		    							"<div class='el-progress-bar__inner'></div>"+
		    						"</div>"+
		    					"</div>"+
		    					"<div class='el-progress__text' style='font-size: 12.8px;'></div>"+
		    				"</div>"+
		    			  "</li>";
		    		//已绘制个数增1
		    		drawedNum++;	    		
				}
				$('#uploadedFileList').append(str);		
      	}
		//文件覆盖确认不能像文件错误确认一样封装成函数的原因在于，文件复制会存在两种种情况：继续、异步等待用户确认，文件错误确认只有一种情况：异步等待用户确认
      	//获取当上传的文件覆盖设置
      	function getFileCoverConfirmSetting()
      	{
	 		if(fileCoverConfirmSet == 0) //全局设置为直接覆盖
  	 		{
  	 			if(SubContextList[index].fileCoverConfirmSet == 0)
  	 			{
  	 				return 0;
  	 			}
  	 		
  	 			return SubContextList[index].fileCoverConfirmSet;	 			
  	 		}
  	 		
	 		return fileCoverConfirmSet;
      	}
      	
      	//文件覆盖处理接口
      	function fileCoverConfirm(docName,msgInfo)
      	{
      		//检查当前目录下是否有同名文件或目录
  	 		var confirm = getFileCoverConfirmSetting();
	  	 	if(confirm == 1)
	  	 	{
	  	 		//用户已确认直接覆盖
	  	 		uploadDoc();
	  	 		return;
	  	 	}
	  	 	else if(confirm == 2)
	  	 	{
	  	 		uploadErrorHandler(docName,"文件" + docName + " 已存在，自动跳过");
	  	 		return;
	  	 	}
	  	 	else
	  	 	{
		        var fileCoverTimer = setTimeout(function () {	//超时用户没有动作，则直接覆盖
		            	console.log("fileCoverConfirm() 是否覆盖 " + docName + ",用户确认超时,采用覆盖且后续自动覆盖");
		            	SubContextList[index].fileCoverConfirmSet = 1; //覆盖
		            	fileCoverConfirmSet = 1;
		            	closeBootstrapDialog("fileCoverConfirm");
		            	uploadDoc(); //reEnter uploadDoc
		            },5*60*1000);	//5分鐘用戶不確認則關閉對話框
		        
	    	    qiao.bs.confirm({
	    	    	id: 'fileCoverConfirm',
	    	        msg: docName + "已存在,是否覆盖?",
	    	        close: false,		
	    	        okbtn: "替换",
	    	        qubtn: "跳过",
	    	    },function () {
	               	console.log("fileCoverConfirm() 用户选择覆盖 " + docName);
	       		 	clearTimeout(fileCoverTimer);
	 	 			SubContextList[index].fileCoverConfirmSet = 1; //覆盖
	  	 			if(index < (totalNum-1)) //后续还有才提示
	  	 			{
		  	 			var fileCoverTimer1 = setTimeout(function () {	//超时用户没有动作，则直接覆盖
		 	            	console.log("fileCoverConfirm() 后续已存在文件是否自动覆盖，用户确认超时,后续自动覆盖");
		 	            	fileCoverConfirmSet = 1;
		 	            	closeBootstrapDialog("takeSameActionConfirm1");
		 	            	uploadDoc(); //reEnter uploadDoc
		 	            },5*60*1000);	//5分鐘用戶不確認則關閉對話框
		 	            
	  	 	    	    qiao.bs.confirm({
	  	 	    	    	id: 'takeSameActionConfirm1',
	  	 	    	        msg: "后续已存在文件是否自动覆盖？",
	  	 	    	        close: false,		
	  	 	    	        okbtn: "是",
	  	 	    	        qubtn: "否",
	  	 	    	    },function () {
	  	 	           		console.log("fileCoverConfirm() 后续已存在文件将自动覆盖");
	  			 	    	clearTimeout(fileCoverTimer1);
	  	 	    	    	fileCoverConfirmSet = 1;	//全局覆盖
	  	  	 				uploadDoc(); //reEnter uploadDoc
	  	  	 				return true;
	  	 				},function(){
	  	 		       		console.log("fileCoverConfirm() 后续已存在文件不自动覆盖");
	  	 					clearTimeout(fileCoverTimer1);
	  	 					uploadDoc(); //reEnter uploadDoc
	  	  	 				return true;
	  	 				});
	  	 			}
	  	 			else
	  	 			{
	  	 				uploadDoc(); //reEnter uploadDoc
	  	 			}
	    	    	return true;   
	    	    },function(){
	    	    	console.log("fileCoverConfirm() 用户选择跳过上传 " + docName);
	    	    	clearTimeout(fileCoverTimer);
	
	  	 			SubContextList[index].fileCoverConfirmSet = 2; //不覆盖
	  	 			if(index < (totalNum-1)) //后续还有才提示 
	  	 			{
		  	 			var fileCoverTimer2 = setTimeout(function () {	//超时用户没有动作，则直接覆盖
		 	            	console.log("fileCoverConfirm() 后续已存在文件是否自动跳过，用户确认超时，后续自动跳过！");
		 	            	fileCoverConfirmSet = 2;
		 	            	closeBootstrapDialog("takeSameActionConfirm2");	 	            	
		 	            	uploadErrorHandler(docName,"后续已存在文件是否自动跳过，用户确认超时，跳过且后续自动跳过！");
		 	            },5*60*1000);	//5分鐘用戶不確認則關閉對話框
	  	 				
	  	 	    	    qiao.bs.confirm({
	  	 	    	    	id: 'takeSameActionConfirm2',
	  	 	    	        msg: "后续已存在文件是否自动跳过？",
	  	 	    	        close: false,		
	  	 	    	        okbtn: "是",
	  	 	    	        qubtn: "否",
	  	 	    	    },function () {
	  	 	    	    	console.log("fileCoverConfirm() 后续已存在文件自动跳过！");
	  	 	    	    	clearTimeout(fileCoverTimer2);
	  	 					fileCoverConfirmSet = 2;	//全局覆盖
	  	 					uploadErrorHandler(docName,"文件已存在，跳过且后续自动跳过");
	  	  	 				return true;
	  	 				},function(){
	  	 					console.log("fileCoverConfirm() 后续已存在文件不自动跳过！");
	  	 	    	    	clearTimeout(fileCoverTimer2);
	  						uploadErrorHandler(docName,"文件已存在，跳过但后续不自动跳过");
	  	  	 				return true;
	  	 				});			
	  	 			}
	  	 			else
	  	 			{
	  	 				uploadErrorHandler(docName,"文件已存在，跳过");
	  	 			}
	    	    	return true;
	    	    });      		
      	 	}
      	}
      	
      	//获取当上传的文件覆盖设置
      	function getUploadErrorConfirmSetting()
      	{
	 		if(uploadErrorConfirmSet == 0) //全局设置为直接覆盖
  	 		{
  	 			if(SubContextList[index].uploadErrorConfirmSet == 0)
  	 			{
  	 				return 0;
  	 			}
  	 		
  	 			return SubContextList[index].uploadErrorConfirmSet;	 			
  	 		}
  	 		
	 		return uploadErrorConfirmSet;
      	}
      	
      	//upload Error Confirm
      	function uploadErrorConfirm(FileName,errMsg)
      	{
      		var uploadErrorTimer = setTimeout(function () {	//超时用户没有动作，则直接覆盖
            	console.log("用户确认超时,继续上传后续文件");
            	SubContextList[index].uploadErrorConfirmSet = 1; //继续上传
            	uploadErrorConfirmSet = 1; //全局继续上传
            	closeBootstrapDialog("uploadErrorConfirm");
            	uploadErrorHandler(FileName,errMsg);
            },5*60*1000);	//5分鐘用戶不確認則關閉對話框
      		
			//弹出用户确认窗口
      		qiao.bs.confirm({
    	    	id: 'uploadErrorConfirm',
    	        msg: FileName + "上传失败（"+errMsg+"）,是否继续上传其他文件？",
    	        close: false,		
    	        okbtn: "继续",
    	        qubtn: "结束上传",
    	    },function () {
    	    	//alert("点击了确定");
				clearTimeout(uploadErrorTimer);			
      			SubContextList[index].uploadErrorConfirmSet = 1; //继续上传
    	 		if(index < (totalNum-1))	//后续还有文件
                {
    	      		var uploadErrorTimer1 = setTimeout(function () {	//超时用户没有动作，则直接覆盖
    	            	console.log("用户确认超时,后续错误都继续上传");
    	            	uploadErrorConfirmSet = 1; //全局继续上传
    	            	closeBootstrapDialog("takeSameActionConfirm3");
    	            	uploadErrorHandler(FileName,errMsg);
    	            },5*60*1000);	//5分鐘用戶不確認則關閉對話框
    	 			
  	 	    	    qiao.bs.confirm({
  	 	    	    	id: 'takeSameActionConfirm3',
  	 	    	        msg: "后续错误是否执行此操作？",
  	 	    	        close: false,		
  	 	    	        okbtn: "是",
  	 	    	        qubtn: "否",
  	 	    	    },function () {
  	 	    	    	//后续错误将不再弹出窗口
  	 	    	    	clearTimeout(uploadErrorTimer1);
  	 	    	    	uploadErrorConfirmSet = 1;	//全局覆盖
  	 	    	    	uploadErrorHandler(FileName,errMsg); //reEnter uploadDoc
  	  	 				return true;
  	 				},function(){
  	 					//后续错误将继续弹出错误确认窗口
  	 					clearTimeout(uploadErrorTimer1);
  	 	    	    	uploadErrorHandler(FileName,errMsg);
  	  	 				return true;
  	 				});	
                }
    	 		else
    	 		{
             		uploadErrorConfirmHandler(FileName,errMsg);
             		return;
    	 		}
    		},function(){
    	    	//alert("点击了取消");
    	    	clearTimeout(uploadErrorTimer);
      			SubContextList[index].uploadErrorConfirmSet = 2; //结束所有上传
          		uploadErrorConfirmSet = 2; //全局取消上传    	 		
		 		uploadErrorAbortHandler(FileName,errMsg);
      		});
      	}
      	
      	//uploadErrorConfirmHandler
      	function uploadErrorConfirmHandler(FileName,errMsg)
      	{
			console.log("上传失败：" + errMsg);
			var confirm = getUploadErrorConfirmSetting();
			if(confirm == 1)
			{
				uploadErrorHandler(name, errMsg);
			}
			else if(confirm == 2)	//结束上传
			{
				uploadErrorAbortHandler(name, errMsg);
			}
			else
			{
				uploadErrorConfirm(name, errMsg);
			}
      	}
      	
      	//uploadErrorHandler
      	function uploadErrorHandler(FileName,errMsg)
      	{
      		console.log("uploadErrorHandler() "+ FileName + " " + errMsg);
      		if(false == reuploadFlag)
      		{
      			failNum++;
      		}
      		else
      		{
          		console.log("uploadErrorHandler() 重传出错");
      			reuploadFailNum++;
      		}
      		//设置上传状态
			SubContextList[index].state = 3;	//上传结束
      		SubContextList[index].status = "fail";
			SubContextList[index].msgInfo = errMsg;
			uploadNextDoc();		 	
      	}
      	
      	//uploadErrorAbortHandler
      	function uploadErrorAbortHandler(FileName,errMsg)
      	{
      		console.log("uploadErrorAbortHandler() "+ FileName + " " + errMsg);
      		if(false == reuploadFlag)
      		{
      			failNum++;
      		}
      		else
      		{
          		console.log("uploadErrorAbortHandler() 重传出错");
      			reuploadFailNum++;
      		}
    		//设置上传状态
			SubContextList[index].state = 3;	//上传结束
      		SubContextList[index].status = "fail";
      		SubContextList[index].msgInfo = errMsg;
      		uploadEndHandler();
      	}
      	
      	//uploadSuccessHandler
      	function uploadSuccessHandler(name,msgInfo)
      	{
      		console.log("uploadSuccessHandler() "+ name + " " + msgInfo);
      		
      		successNum++;
	      	
      		if(true == reuploadFlag)
      		{	
	      		console.log("uploadSuccessHandler() 重传成功");
	      		reuploadSuccessNum++;
	      	}
	      	SubContextList[index].state = 2;	//上传结束
      		SubContextList[index].status = "success";
      		SubContextList[index].msgInfo = msgInfo;
			//hide the reupload btn
			$(".reupload"+index).hide();
			uploadNextDoc();
      	}

  		function showUploadEndInfo()
  		{
  			var uploadEndInfo = "上传完成(共" + totalNum +"个)";
      		if(successNum != totalNum)
      		{
      			uploadEndInfo = "上传完成 (共" + totalNum +"个)"+",成功 " + successNum + "个";
      		}
      		else
      		{
      			$(".reuploadAllBtn").hide();
      		}
      		$(".upload-list-title").text(uploadEndInfo);
      		
            // 普通消息提示条
			bootstrapQ.msg({
					msg : '上传结束！',
					type : 'success',
					time : 2000,
				    }); 
            
  			//清除标记
  			isUploading = false;
  			reuploadFlag = false;
  		}

      	//uploadEndHandler
      	function uploadEndHandler()
      	{
      		console.log("uploadEndHandler() 上传结束，共"+ totalNum +"文件，成功"+successNum+"个，失败"+failNum+"个！");
			
      		//显示上传完成 
      		showUploadEndInfo();      		
      		
      		//清除文件控件
			$("#uploadFiles").val("");
  			$("#uploadDir").val("");
            
  			//清除上传中标志
            isUploading = false;
      	}
      	
      	//uploadNextDoc，如果后续有未上传文件则上传下一个文件 
		function uploadNextDoc()
		{
      		if(false == reuploadFlag)
      		{
	      		index++;
				if(index < totalNum)
				{
					uploadDoc(); 
				}
				else
				{
					uploadEndHandler();
				}
      		}
      		else 
      		{
      			reuploadIndex ++;
      			if(reuploadIndex < reuploadTotalNum)
      			{
      				index = reuploadList[reuploadIndex];
      				uploadDoc();
      			}
      			else
      			{
      				uploadEndHandler();
      			}      				
      		}
		}
      	
      	//检查当前上传文件的父节点是否存在，不存在则通知后台新建，直到全部新建完成
 		function checkAddParentNode(SubContext)
 		{
      		var vid = SubContext.vid;
			//parentNode maybe is not the real parent for the doc
			var tempParentNode = SubContext.parentNode;
    		//get filePath form file
    		var filePath = SubContext.relativePath;
    		//console.log("checkAddParentNode() relativePath:" + filePath);

    		if(!filePath || filePath == "")
    		{
    			//文件没有相对路径，realParentNod = parentNode
 				SubContext.realParentNode = tempParentNode;
 				SubContext.realParentId = tempParentNode?tempParentNode.id:0;
    			return true;
    		}
			
    		//文件父目录检查部分
			var pathArray = new Array(); //定义一数组 
			pathArray = filePath.split("/"); //字符分割 

			//检查其其父节点是否存在，如果不存在则需要先新建父节点目录
			for(var i=0; i<pathArray.length-1; i++)	//最后一个是文件本身因此不需要检查
			{
				var nodeName = pathArray[i];
				var treeNode = getNodeByName(nodeName,tempParentNode);	//获取parentNode下名为name的子节点
				if(treeNode)	//节点已存在
				{
					if(treeNode.isParent == true)
					{
						//节点存在且是目录，检查下一级parentNode
						tempParentNode = treeNode;
					}
					else	//同名节点不是目录，此文件则上传失败
					{
						uploadErrorConfirmHandler(name,nodeName + " 不是目录");
			            return false;
					}
				}
				else	//节点不存在，则新建该节点
				{
					//由于后台新增节点是异步调用，所以成功后回调uploadDoc来触发下一级目录的检查
			    	var tempParentId = 0;
			    	if(tempParentNode)
			    	{
			    		tempParentId = tempParentNode.id;
			    	}
			   		console.log("checkAddParentNode() addDoc name:" + nodeName + " type:" +  2 + " tempParentId:" +  tempParentId + " vid:" +  vid);
			    	$.ajax({
			             url : "/DocSystem/Doc/addDoc.do",
			             type : "post",
			             dataType : "json",
			             data : {
			             	name : nodeName,
			                type : 2, //文件类型
			                reposId : vid, 
			                parentId : tempParentId,
			             },
			             success : function (ret) {
			             	if( "ok" == ret.status && ret.data.id){
			             		if(ret.msgData == "isNewNode")
			             		{
			             			addTreeNode(nodeName,true,ret.data.id,tempParentNode);
			             		}
			             		else
			             		{
			             			//Dir Node exists, we just open the parentNode is ok
			         				var treeObj = $.fn.zTree.getZTreeObj("doctree");
			         				treeObj.expandNode(tempParentNode, true, false, true);
			             		}

			             		console.log("checkAddParentNode() call uploadDoc to reenter the code");
			        		  	uploadDoc();
			        		  	return;
				            }
			                else
			                {
							 	uploadErrorConfirmHandler(name,ret.msgInfo);
					            return;
			                }
			            },
			            error : function () {
						 	uploadErrorConfirmHandler(name,"新增目录 "+nodeName+ " 异常");
				            return;
			            }
			        });
					return false;
				}
			}
			SubContext.realParentNode = tempParentNode;
			SubContext.realParentId = tempParentNode?tempParentNode.id:0;
			return true;
 		}
      	
 		var CheckSumCaculator = (function(){
 			var caculateIndex = 0;
 			var reuploadCaculateIndex = 0;
 			
 	      	//由于FileReader是异步调用，因此该接口也是异步调用，结果会保存在SubContext.checkSum中
 	      	function caculate()
 	      	{
 	      		console.log("caculateFileCheckSum() caculateIndex:" + caculateIndex);
 	      		var SubContext = SubContextList[caculateIndex];
 	 			if(1 == SubContext.checkSumState)
 	          	{
 	      			console.log("caculateFileCheckSum() checkSum is caculating for: " + SubContext.name );
 	      			return;
 	          	}
 	      		else if(2 == SubContext.checkSumState)
 	      		{
 	      			//console.log("caculateFileCheckSum() checkSum is ready for:" + SubContext.name);
 	      			caculateNext();
 	      			return;
 	      		}
 	      		
 	      		//start to caculate the checkSum for SubContext
 	      		console.log("caculateFileCheckSum() start caculate checkSum for:",SubContext);
 	      		var blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,
 	            	file = SubContext.file,
 	            	chunkSize = 2097152,                           // read in chunks of 2MB
 	            	chunks = Math.ceil(SubContext.size / chunkSize),
 	            	currentChunk = 0,
 	            	spark = new SparkMD5(),
 	            	time,
 	            	uniqueId = 'chunk_' + (new Date().getTime()),
 	            	chunkStep = 1,
 	            	fileReader = new FileReader();
 	      		
 	      		//console.log("caculateFileCheckSum() blobSlice",blobSlice);
 	      		
 		        fileReader.onload = function (e) {
 		            //console.log("currentChunk=" + currentChunk);
 		            if(stopUploadFlag == true || SubContext.stopUploadFlag == true)
 		            {
 		            	console.log("caculateFileCheckSum() upload was stoped, stop caculate");
 		                return;
 		            }
 		            
 		            if (currentChunk === 0) {
 		                console.log("caculateFileCheckSum() Read chunk number id=" + uniqueId + " + currentChunk=" + (currentChunk + 1) + " chunks=" + chunks);
 		                if(chunks > 10)
 		                {
 		                	chunkStep = chunks / 10;
 		                }
 		                console.log("caculateFileCheckSum() chunkStep=" + chunkStep);
 		            }
 		
 		            spark.appendBinary(e.target.result);                 // append array buffer
 		            currentChunk += chunkStep;
 		
 		            if (currentChunk < chunks) {
 		                loadNext();
 		            } else {

 		            	SubContext.checkSum = spark.end();	            	
 		                console.log("caculateFileCheckSum() Computed hash:" + SubContext.checkSum); // computed hash
 		            	SubContext.checkSumState = 2; 		                
 		                
 		                //To caculateNext
 		                caculateNext();
 		            }
 		        };
 		
 		        //Fail to compute hash
 		        fileReader.onerror = function () {
 		        	SubContext.checkSumState = 3;
 	                console.log("caculateFileCheckSum() Fail to Computed hash"); //fail to compute hash
 	                
		            //To caculateNext
		            caculateNext();
 		        };
 		
 		        function loadNext() {
 		            var start = currentChunk * chunkSize;
 		            var end = start + chunkSize >= file.size ? file.size : start + chunkSize;
 		
 		            fileReader.readAsBinaryString(blobSlice.call(file, start, end));
 		        }
 		
 	      		//set the running state
 	      		SubContext.checkSumState = 1;
 	      		SubContext.checkSum = "";
 		        loadNext();
 	      	}
 	      	
 	   		function caculateNext()
 	   		{
 	         	if(false == reuploadFlag)
 	         	{
 	   	      		caculateIndex++;
 	   				if(caculateIndex < totalNum)
 	   				{
 	   					caculate(); 
 	   				}
 	   				else
 	   				{
 	   					console.log("caculateNext() all upload doc checkSum was computed");
 	   				}
 	         	}
 	         	else 
 	         	{
 	         		reuploadCaculateIndex ++;
 	         		if(reuploadCaculateIndex < reuploadTotalNum)
 	         		{
 	         			caculateIndex = reuploadList[reuploadCaculateIndex];
 	         			caculate();
 	         		}
 	         		else
 	         		{
 	         			console.log("caculateNext() for all reupload doc checkSum was computed");
 	         		}			
 	         	}
 	       }
 	   	   
 	   		//开放给外部的调用接口
 	        return {
 	            caculate : function(startId){
 	            	if(false == reuploadFlag)
 	            	{
 	            		caculateIndex = startId;
 	            	}
 	            	else
 	            	{
 	            		reuploadCaculateIndex = startId;
 	            		caculateIndex = reuploadList[reuploadCaculateIndex];
 	            	}
 	            	caculate();
 	            },
 	        };
 		})();
      	
      	
		function getFileCheckSum(SubContext)
		{            
			switch(SubContext.checkSumState)
			{
			case 0:
				 //Start CheckSum Caculator: It will caculate for all upload or reupload Docs
				 console.log("getFileCheckSum() checkSum not computed, start compute");
				 if(false == reuploadFlag)
			     {
					 CheckSumCaculator.caculate(index);					 
			     }
				 else
			     {
					 CheckSumCaculator.caculate(reuploadIndex);					 
			     }
			case 1:
				//Start timer to wait for result
		        console.log("getFileCheckSum() checkSum not ready, wait for result 100 ms later"); 
				setTimeout(function () {
		            uploadDoc(); //reEnter uploadDoc
		        },100);	//check it one minute later
				return false;
			case 2:
				//CheckSum ok
				return true;
			default:
				//CheckSum Error
				SubContext.checkSum = "";
				return true;
			}
		}
      	
      	//返回false表示该接口触发异步调用，当前uploadDoc线程需要先退出，异步回调会根据check结果决定后续是否reenter uploadDoc
      	function checkDocInfo(SubContext)
      	{      		
      		var name = SubContext.name;
	  	 	//console.log("checkDocInfo() file:" + name);

	  	 	//It is the first call for file, so we need to check the docInfo
	  	 	//console.log("checkDocInfo() SM [" + SubContext.SMState + "," + SubContext.SMSubState + "]");
   			if("checkDocInfo" == SubContext.SMState && 1 == SubContext.SMSubState)
   			{
   				return true;
   			}
   			
   			console.log("checkDocInfo() for file:"+ name);
   			//Modify the SM
      		SubContext.SMState = "checkDocInfo";
      		SubContext.SMSubState = 1;
      		
      		//检查服务器端是否存在同名文件，并确认文件内容是否相同
   			//调用后台接口检查DocInfo，回调函数需要根据情况决定具体的操作
  			$.ajax({
	             url : "/DocSystem/Doc/checkDocInfo.do",
	             type : "post",
	             dataType : "json",
	             data : {
	             	name : name,
					type: 1,
					size: SubContext.size,
	             	checkSum: SubContext.checkSum,
	             	reposId : SubContext.vid, 
	                parentId : SubContext.realParentId,
	             },
	             success : function (ret) {
	             	if( "ok" == ret.status)
	             	{		
	             		console.log("checkDocInfo() ret",ret);
	             		if(ret.msgData == "0")	//文件存在但checkSume不同，等待用户确认是否覆盖
	             		{
	             			SubContext.docId = ret.data;
	             			fileCoverConfirm(name,"文件" + name + " 已存在");
	             			return;
	             		}
	             		else if(ret.msgData == "1")	//文件存在且checkSum相同，直接标记成功
	             		{
		                	if(SubContext.docId == -1) //文件新建成功
			                {	
			             		addTreeNode(name,false,ret.data,SubContext.realParentNode);
			             		//set the docId so that We can open it 
		             			SubContext.docId = ret.data;	                
			                }
	             			
	             			$('.file'+index).removeClass('is-uploading');
		    				$('.file'+index).addClass('is-success');
		                    uploadSuccessHandler(name,ret.msgInfo);
							return;
	             		}
	             		else
	             		{
	             			//doc not exists, let's resume the uploadDoc
	             			uploadDoc();
	             			return;
	             		}
	                }
	                else
	                {
					 	uploadErrorConfirmHandler(name,ret.msgInfo);
			            return;
	                }
	            },
	            error : function () {
				 	uploadErrorConfirmHandler(name,"doCheck "+nodeName+ " 异常");
		            return;
	            }
	        });
    		
   			return false;
      	}
      	
      	function showUploadingInfo()
      	{
      		if(reuploadFlag == false)
      		{
	      		$(".upload-list-title").text("正在上传   " + uploadedNum + " / " + totalNum);
      		}
      		else
      		{
      			$(".upload-list-title").text("正在重传   " + reuploadedNum + " / " + reuploadTotalNum);
      		}
      	}
      	
		//重新上传所有失败文件（包括用户自己选择取消上传的文件）
		function reuploadFailDocs(id)
		{
			//首次上传未结束
			if(false == reuploadFlag && true == isUploading)
			{
				console.log("reuploadFailDocs() 首次上传未结束,不能重传失败文件");
				return;
			}
			
			if(false == reuploadFlag && false == isUploading)
			{	
				console.log("reuploadFailDocs() 启动重传");

				//开始重传
				reuploadList = [];
				reuploadIndex = 0;
				reuploadTotalNum = 0;
		        reuploadedNum = 0;
		    	reuploadFailNum = 0;
		        reuploadSuccessNum = 0;
				stopUploadFlag = false;
				fileCoverConfirmSet = 0;
				uploadErrorConfirmSet = 0;
			}
			else
			{
				console.log("reuploadFailDocs() 重传进行中,更新重传列表即可");
			}
	        
			//Build reupload List
			if(id)
			{
				setSubContextForReupload(id);
			}
			else
			{
				//由于push会pop后进的id,会导致先上传还未绘制进度条的文件，因此反过来遍历
				for(i=0; i<totalNum;i++)
				{
					setSubContextForReupload(i);
				}
			}
			
			console.log("reuploadFailDocs() 重传个数："+reuploadTotalNum);
			if(0 == reuploadTotalNum )
			{
				console.log("reuploadFailDocs() 没有需要重传的Doc");
				return;	
			}
			
			//更新上传进度
			showUploadingInfo();
			
			if(false == reuploadFlag && false == isUploading)
			{
				reuploadFlag = true;
				isUploading = true;
				//trigger uploadDoc
				reuploadIndex = 0;
				index = reuploadList[reuploadIndex];
				console.log("reuploadFailDocs() 重传开始" + index);
				uploadDoc();
			}
		}
		
		function setSubContextForReupload(id)
		{
			SubContext = SubContextList[id];
			
			//console.log("setSubContextForReupload()",SubContext);
			//已成功地不能重传
			if(2 == SubContext.state)
			{
				return;
			}
			
			//避免在上传过程中，被多次重传
			if(true == reuploadFlag)
			{
				if(true == SubContext.reuploadFlag)
				{
					return;
				}
			}
			SubContext.reuploadFlag = true;
				
			//其他所有状态的都可以重传
			reuploadTotalNum ++;

			//Reset all basick SubContext 
			SubContext.state = 0;
			if(SubContext.checkSumState != 2) //checkSum is not ready, need to recaculate the checkSum
			{
				SubContext.checkSumState = 0; 
			}
			//CheckDocInfo should be reCheck
			SubContext.SMState = "init";
			SubContext.SMSubState = 0;
			//stopUploadFlag should be clean
			SubContext.stopUploadFlag = false;
			//confirmSet should be clean
			SubContext.fileCoverConfirmSet = 0;
			SubContext.uploadErrorConfirmSet = 0;
			
			reuploadList.push(id);
		}
		
		//CutFile will cut file to dedicated size slice
		function CutFile(SubContext)
		{ 	
			if(0 == SubContext.cutFileState)
			{
				console.log("CutFile() for", SubContext);
				var cutSize = 2097152;
				var minCutSize = cutSize * 10;
				if(SubContext.size < minCutSize)	//< 20M do not cut
				{
					SubContext.cutFileState = 2;
					console.log("CutFile() file size less than minCutSize " + minCutSize);
					return true;
				}
				
				console.log("CutFile() start to cut file");
				SubContext.chunked = true;
				SubContext.cutSize = cutSize;
				SubContext.cutFileState = 1;
				SubContext.chunkIndex = 0;
				SubContext.chunkNum = Math.ceil(SubContext.size / cutSize);
				//Build ChunkList
				var chunkList = [];
				for(i=0; i< SubContext.chunkNum; i++)
				{
					var chunk = [];
					var start = i * cutSize;
					chunk.start= start;
					chunk.end =  start + cutSize >= SubContext.size ? SubContext.size : start + cutSize;
					chunk.chunkSize = chunk.end - chunk.start;
					chunk.checkSum = "";
					chunk.checkSumState = 0;
					chunk.uploadedState = 0;
					chunkList.push(chunk);
				}
				SubContext.chunkList = chunkList;
				console.log("CutFile() cut ok",SubContext);
			}
			else if(2 == SubContext.cutFileState)
 	      	{
 	      		//console.log("CutFile() completed for:",SubContext);
 	      		return true;
 	      	}
 	      	else
 	      	{
 	      		console.log("CutFile() is in processing for: ",SubContext);
	      		return false;
 	      	}
 	      		
 	      	//start to caculate the chunk checkSum
 	      	console.log("CutFile() start to caculate chunk checkSum for:" + SubContext.name);
 	      	var blobSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice,
 	            	file = SubContext.file,
 	            	cutSize = cutSize,                           // read in chunks of 2MB
 	            	chunks = SubContext.chunkNum,
 	            	currentChunk = 0,
 	            	fileReader = new FileReader();
 	      		
        	fileReader.onload = function (e) {
            	if(stopUploadFlag == true || SubContext.stopUploadFlag == true)
            	{
            		console.log("CutFile() upload was stoped, stop caculate chunk checkSum");
                	return;
            	}
    	      	var hash = SparkMD5.hashBinary(e.target.result);   //compute Data Hash
    	      	SubContext.chunkList[currentChunk].checkSum = hash;
    	      	SubContext.chunkList[currentChunk].checkSumState = 2;		            	
            	console.log("CutFile() Chunk " + currentChunk + " data read ok, checkSum is " + hash);
            	
            	//Try to start read next chunk data
            	currentChunk ++;
            	if (currentChunk < chunks) {
                	loadNext();
            	}
            	else
            	{
            		console.log("CutFile() all chunks checkSum is ready ",SubContext);
                	SubContext.cutFileState = 2;
            		return;
            	}
            };
		        
		    function loadNext() {
		    	//console.log("loadNext()");
		    	SubContext.chunkList[currentChunk].checkSumState = 1;
		        var start = SubContext.chunkList[currentChunk].start;
		        var end = SubContext.chunkList[currentChunk].end;
		        //console.log("loadNext() ",start,end);
		        fileReader.readAsBinaryString(blobSlice.call(file, start, end));
		    }
		    
	      	//Trigger the fileRead
		    loadNext();
		    return false;
		}
		
		function isLastChunk(SubContext)
		{
			if(SubContext.chunkIndex == SubContext.chunkNum -1)
			{
				return true;
			}
			return false;
		}
		
		function getChunkCheckSum(SubContext)
		{            
			console.log("getChunkCheckSum() chunkIndex:" + SubContext.chunkIndex)
			var chunk = SubContext.chunkList[SubContext.chunkIndex];
			switch(chunk.checkSumState)
			{
			case 0:
			case 1:
				//Start timer to wait for result
		        console.log("getChunkCheckSum() chunk checkSum not ready, wait for result 100 ms later"); 
				setTimeout(function () {
		            uploadDoc(); //reEnter uploadDoc
		        },100);	//check it one minute later
				return false;
			case 2:
				//CheckSum ok
				return true;
			default:
				//CheckSum Error
				SubContext.checkSum = "";
				return true;
			}
		}
		
      	function checkChunkUploaded(SubContext)
      	{      		
      		var name = SubContext.name;
	  	 	console.log("checkChunkUploaded() for file:"+ name);
	  	 	
   			var chunk = SubContext.chunkList[SubContext.chunkIndex];
	  	 	if(0 != chunk.uploadedState)
	  	 	{
	  	 		return true;
	  	 	}
   			
   			//检查服务器端是否存在分片文件（checkHash should same）
   			//调用后台接口检查chunk，并设置chunk.state re-enter upload
  			$.ajax({
	             url : "/DocSystem/Doc/checkChunkUploaded.do",
	             type : "post",
	             dataType : "json",
	             data : {
	             	name : name,
	             	docId: SubContext.docId,
	             	size: SubContext.size,
	             	checkSum: SubContext.checkSum,
	             	chunkIndex: SubContext.chunkIndex,
	             	chunkNum: SubContext.chunkNum,
	             	cutSize: SubContext.cutSize,
	             	chunkSize: chunk.chunkSize,
	             	chunkHash: chunk.checkSum,
	             	reposId : SubContext.vid, 
	                parentId : SubContext.realParentId,
	             },
	             success : function (ret) {
	             	if( "ok" == ret.status)
	             	{		
	             		console.log("checkChunkUploade() ret",ret);
	             		if(ret.msgData == "0")	//分片文件不存在 
	             		{
	             			chunk.uploadedState = 1;
	             			uploadDoc();
	             			return;
	             		}
	             		else
	             		{
	             			chunk.uploadedState = 2;
	             			
	             			//Show current doc upload progress
	             			SubContext.uploadedSize += chunk.chunkSize
	             			console.log("checkChunkUploaded() uploadedSize:" + SubContext.uploadedSize + " fileSize:" +   SubContext.size);
	    					var per =  Math.floor(100 * SubContext.uploadedSize / SubContext.size);
	    					$('.file'+index+' .el-progress__text').text(per+"%");
	    					$('.file'+index+' .el-progress-bar__inner')[0].style.width=per+'%';
							
	    					console.log("checkChunkUploaded() chunkIndex:" + SubContext.chunkIndex + " chunkNum:" +   SubContext.chunkNum);
	    					//the last chunk exists
	    					if(SubContext.chunkIndex == (SubContext.chunkNum -1))
	    					{
	    						console.log("checkChunkUploaded() All chunks uploaded",SubContext);
		    					
		    					//All Chunk Uploaded, means file upload ok, 这里的逻辑是有问题的，因为没有ret
		    		        	if(SubContext.docId == -1) //文件新建成功
		    		            {	
		    		         		addTreeNode(name,false,ret.data.id,SubContext.realParentNode);
		    		         		//set the docId so that We can open it 
		    		         		SubContext.docId = ret.data.id;
		    						
		    		            }
		    					//update the uploadStatus
		    					$('.file'+index).removeClass('is-uploading');
		    					$('.file'+index).addClass('is-success');
		    					uploadSuccessHandler(name,ret.msgInfo);
	    					}
	    					else
	    					{
	    						//re enter uploadDoc to upload next trunk
	    						SubContext.chunkIndex++;
	    						uploadDoc();
	    					}
	             			return;
	             		}
	                }
	                else
	                {
					 	uploadErrorConfirmHandler(name,ret.msgInfo);
			            return;
	                }
	            },
	            error : function () {
				 	uploadErrorConfirmHandler(name,"checkChunkUploade "+name+ " 异常");
		            return;
	            }
	        });
   			return false;
      	}
		
		function startChunkUpload(SubContext)
		{ 
			if(SubContext.chunkIndex <  SubContext.chunkNum)
			{
   	   			if(false == getChunkCheckSum(SubContext))
   	   			{
   	   				//checkSum for chunk is not ready, timer be called, callback will re-enter uploadDoc 100ms later
   	   				return;
   	   			}
	   			
   	   			//检查Chunk是否存在且是否相同，return false 表示内部有异步调用
   	   			if(false == checkChunkUploaded(SubContext))
   	   			{
   	    			console.log("startChunkUpload() checkChunkUploaded be called, callback will re-enter uploadDoc");   				
   	   				return;
   	   			}
	   			
   	   			//根据chunk.state决定是否上传
   	   			var chunk = SubContext.chunkList[SubContext.chunkIndex];
   				if(1 == chunk.uploadedState)	//current chunk not uploaded
   				{
	   				startUpload(SubContext); //Do Upload the chunk
	   				return;
   				}
			}
		}
		
    	function startUpload(SubContext)
    	{

			console.log("startUpload() docId:" + SubContext.docId,SubContext);

			//新建文件上传表单
			var form = new FormData();
			if(false == SubContext.chunked)
			{
				form.append("name", SubContext.name);
				form.append("filePath", SubContext.filePath);
				form.append("size", SubContext.size);
				form.append("checkSum", SubContext.checkSum);
				form.append("docId", SubContext.docId);
				form.append("parentId", SubContext.realParentId);
				form.append("reposId", SubContext.vid);
				form.append("uploadFile", SubContext.file);
			}
			else
			{
				//根据chunkIndex上传
				form.append("name", SubContext.name);
				form.append("filePath", SubContext.filePath);
				form.append("size", SubContext.size);
				form.append("checkSum", SubContext.checkSum);
				form.append("docId", SubContext.docId);
				form.append("parentId", SubContext.realParentId);
				form.append("reposId", SubContext.vid);
				
				var chunkIndex = SubContext.chunkIndex;
				var chunkNum = SubContext.chunkNum;
				var chunk = SubContext.chunkList[chunkIndex];
				console.log("startUpload() chunkIndex:" + chunkIndex + " chunkNum:" + chunkNum, chunk);
				var chunkData = SubContext.file.slice(chunk.start,chunk.end);
				console.log("startUpload() chunkData:",chunkData);
				form.append("chunkIndex", chunkIndex);
				form.append("chunkNum", chunkNum);
				form.append("cutSize",SubContext.cutSize);
				form.append("chunkSize",chunk.chunkSize);
				form.append("chunkHash", chunk.checkSum);
				form.append("uploadFile", chunkData);
			}
			
			var name = SubContext.name;
			//新建http异步请求
			var xhr = new XMLHttpRequest();
			
			//设置异步上传状态变化回调处a理函数
			xhr.onreadystatechange = function() {				
				//文件上传状态
				console.log("xhr onreadystatechange() status:" + xhr.status + " readyState:" + xhr.readyState);
				if(xhr.status == 200) 
				{
					if(xhr.readyState != 4)
					{
						//文件上传未结束
						return;
					}
					
					//上传成功！
					var ret = JSON.parse(xhr.responseText);
					if("ok" == ret.status){
						if(true == SubContext.chunked && false == isLastChunk(SubContext))
						{
							//分片上传未结束,re-enter uploadDoc to upload next chunk
							SubContext.chunkIndex++;
							uploadDoc();
							return;
						}
						
	                	if(SubContext.docId == -1) //文件新建成功
		                {	
		             		addTreeNode(name,false,ret.data.id,SubContext.realParentNode);
		             		//set the docId so that We can open it 
		             		SubContext.docId = ret.data.id;
							
		                }
	                	
						//update the uploadStatus
						$('.file'+index).removeClass('is-uploading');
						$('.file'+index).addClass('is-success');
						uploadSuccessHandler(name,ret.msgInfo);
					 }
					 else	//上传失败
					 {
						//上传失败
						console.log("上传失败：" + ret.msgInfo);
	
						//update the uploadStatus
						$('.file'+index).removeClass('is-uploading');
						$('.file'+index).addClass('is-fail');
						uploadErrorConfirmHandler(name, ret.msgInfo);
						return;
		             }
				}else{
					if(xhr.status < 300) 
					{
						//不是真正的异常
						return;
					}
					//上传失败
					console.log("系统异常: " + name + " 上传异常！");
					$('.file'+index).removeClass('is-uploading');
					$('.file'+index).addClass('is-fail');
					uploadErrorConfirmHandler(name, name + " 上传异常！");
					return;
				}
			};
			
			//设置异步上传进度回调处理函数
			xhr.upload.onprogress = function(evt) {
				//由于xhr.abort不能立即结束上传，因此会导致uploadErrorHandler多次被调用而导致状态机混乱，因此目前处理方式只对未开始上传的文件有效
				if(stopUploadFlag == true || SubContextList[index].stopUploadFlag == true)
				{
					console.log("stopUploadFlag: " + stopUploadFlag + " SubContextList[index].stopUploadFlag:" + SubContextList[index].stopUploadFlag);	
					if(true == SubContextList[index].stopUploadFlag)	//we need to promise there is only one abort for one doc upload
					{
						SubContextList[index].stopUploadFlag = false;
						xhr.abort(); //结束当前上传	 
						uploadErrorHandler(name, name + " 取消上传！");
					}
					return;
				}
				
				//文件上传进度(evt获取到的是上传的所有数据的百分比，所有比实际文件要大)
				var loaded = evt.loaded;	//已上传大小
				var tot = evt.total;
				var per = Math.floor(100 * loaded / tot); //已经上传的百分比
				console.log("upload.onprogress loaded:" + loaded + " tot:" + tot + " per:" + per);
				
				//计算实际文件的分片上传进度
				if(SubContext.chunked)
				{
					var uploadedChunkSize = (per * SubContext.chunkList[SubContext.chunkIndex].chunkSize)/100;
					var realUploaedSize = SubContext.uploadedSize +  uploadedChunkSize;
					if(per == "100")	//单片上传结束
					{
						SubContext.uploadedSize = realUploaedSize;
					}
					per =  Math.floor(100 * realUploaedSize / SubContext.size);
				}
				
				//计算当前文件上传百分比
				$('.file'+index+' .el-progress__text').text(per+"%");
				$('.file'+index+' .el-progress-bar__inner')[0].style.width=per+'%';
				console.log("上传中："+per+"%！"); 
	
				//统计总的已上传大小、百分比、上传速度、剩余上传时间
				uploadTime = new Date().getTime();
				if(per=="100")
				{
					uploadedFileSize = uploadedFileSize + tot; //已完成上传的文件大小
					uploadedSize = uploadedFileSize;
				}
				else
				{
					uploadedSize = uploadedFileSize + loaded;
				}
				var remainSize = totalSize - uploadedSize;
				var usedTime = (uploadTime - uploadStartTime)/1000; //转换成秒
	    		//console.log("totalSize:" + totalSize + " remainSize:" + remainSize + " preUploadSize:" + preUploadSize + " uploadedSize:"+ uploadedSize);
	    		if(remainSize < 0)
	    		{
	    			remainSize = 0;
	    		}
				
				var perTime = (uploadTime - preUploadTime)/1000;
	    		//console.log("preUploadTime:" + preUploadTime + " uploadTime:" + uploadTime + " perTime:" + perTime);
				if(perTime > 1)	//每10秒更新一次下载速度
	    		{
	    			var bspeed = (uploadedSize - preUploadSize)/perTime; //上传速度(b/s)
	        		uploadSpeed = bspeed;
	        		preUploadSize = uploadedSize;
					preUploadTime = uploadTime;
	    		}				
	    		var remainTime = remainSize/uploadSpeed;
	    		var totPer = Math.floor(100 * uploadedSize / totalSize);
				//计算显示用speed和时间
	    		var speed = uploadSpeed;
				var units = "b/s";	//速度单位
				if((speed/1024)>1)
				{
					speed = speed/1024;
					units = "k/s";
					if((speed/1024)>1)
					{
						speed = speed/1024;
						units = "M/s";
					}
				}
	       		//console.log("上传速度："+ speed + units);
				//console.log("总进度：" + totPer + " 已用时间：" + usedTime + " 剩余时间：" + remainTime);
			};
			
			//上传表单			
			xhr.open("post", "/DocSystem/Doc/uploadDoc.do");
			xhr.send(form);
			uploadTime = new Date().getTime();	//上传时间初始化
    	}
    	
		//uploadDoc接口，该接口是个递归调用
    	function uploadDoc()
    	{
    		//console.log("uploadDoc() index:" + index + " totalNum:" + totalNum);
    		var SubContext = SubContextList[index];
			
    		//判断是否取消上传
    		if(stopUploadFlag == true)
    		{
    			console.log("uploadDoc(): 结束上传");
    			uploadEndHandler();
    			return;
    		}
    		
    		//取消当前文件上传
			if(SubContext.stopUploadFlag == true)
			{
				console.log("uploadDoc() 用户取消了上传 "+ name);
    			uploadErrorHandler(name,"用户取消了上传！");
				return;
			}
    		
    		//设置上传状态
    		if(0 == SubContext.state)
    		{   
    			console.log("uploadDoc() 开始上传 fileName:" + SubContext.name,SubContext);
				SubContext.state = 1;	//上传中
				SubContext.uploadedSize = 0; //Clear uploadedSize

				if(false == reuploadFlag)
    			{
    				uploadedNum++;
    			}
    			else
    			{
    				reuploadedNum++;
    			}
				
				showUploadingInfo();
				
				//get the file from the SubContextList
    			var file = SubContext.file;
				if(!file) 
				{
					uploadErrorHandler("未知","不是文件");
					return; 
				}
    		}
    		
    		//每次上传前检查是否需要绘制，小于200个上传项目时绘制
    		checkAndDrawUploadItems(SubContextList);
			
    		//文件父目录检查部分，uploadDoc每次进来都需要检查，return false表示内部有异步调用
    		if(false == checkAddParentNode(SubContext))
    		{
    			console.log("uploadDoc() checkAddParentNode return false, addDoc have been called, callback will re-enter uploadDoc");
    			return;
    		}
   			//console.log("uploadDoc() checkAddParentNode completed");
   		 	
   			if(false == getFileCheckSum(SubContext))
   			{
   				//checkSum is not ready, timer be called, callback will re-enter uploadDoc 100ms later
   				return;
   			}
   			
   			//检查文件是否存在且是否相同，return false 表示内部有异步调用
   			if(false == checkDocInfo(SubContext))
   			{
    			console.log("uploadDoc() checkDocInfo be called, callback will re-enter uploadDoc");   				
   				return;
   			}
   			//console.log("uploadDoc() checkDocInfo completed"); 
			
   			//该接口只对大于50M的文件进行切片，设置chunked标记，生成chunkList（chunkHash或者叫chunkCheckSum并没有完全生成，所以后续getChunkedSum可能需要等待）
   			CutFile(SubContext); 
   			
   			if(false == SubContext.chunked) 
   			{
   	   			startUpload(SubContext);
   	   			return;
   			}
   			else
   			{
   				startChunkUpload(SubContext);	
   			}
    	}
		
		function stopUpload(index)
		{
			console.log("stopUpload() index:" + index ,SubContextList[index]);
			SubContextList[index].stopUploadFlag = true;
		}
		
		function stopAllUpload()
		{
			//将未上传的全部设置
			for(i=index;i<totalNum;i++)
			{
				SubContextList[i].stopUploadFlag = true;
			}
			stopUploadFlag = true;
			
  			//清除标记
  			isUploading = false;
  			reuploadFlag = false;
		}
				
		//开放给外部的调用接口
        return {
            uploadDocs: function(files,parentNode,parentId,vid){
            	uploadDocs(files,parentNode,parentId,vid);
            },
            stopAllUpload: function(){
            	stopAllUpload();
            },
            stopUpload: function(id){
            	stopUpload(id);
            },
            getUploadStatus: function(){
            	return getUploadStatus();
            },
            reuploadFailDocs: function(id){
            	return reuploadFailDocs(id);
            },
        };
    })();

	//Re Upload Fail Docs
    function reuploadFailDocs(index)
    {
    	console.log("reuploadFailDocs() index:" + index);
    	DocUpload.reuploadFailDocs(index);    	
    }
    	
	//Stop Upload
	function stopUpload(index)
	{
    	//var index = $(this).attr('value');	//value 不是i的原生属性，所以不能用value
    	console.log("stopUpload " + index);
    	DocUpload.stopUpload(index);
    }
	
	//删除多余的treeNode
	function deleteDuplicatedTreeNode(name,parentNode)
    {
		console.log("deleteDuplicatedTreeNode",name,parentNode);
		var treeObj = $.fn.zTree.getZTreeObj("doctree");
		var nodes = treeObj.getNodesByParam("name", name, parentNode);
		console.log(nodes);
		if(nodes!=null && nodes.length > 1)
		{
			var size = nodes.length;
			var i = 1;
			//删除多余的treeNode
			for(i=1;i<size;i++)
			{
				Node = nodes[i];
				treeObj.removeNode(Node);
			}
		}
		return;
    }
	
	function deleteTreeNode(name,parentNode)
    {
		console.log("deleteTreeNode",name,parentNode);
		var NodeIndex = -1;
		var treeObj = $.fn.zTree.getZTreeObj("doctree");
		var Node = treeObj.getNodeByParam("name", name, parentNode); //找到新的目录下，id与被复制的节点相同id的Node(这是zTree自动产生的，我要删掉他)
		if(Node!=null)
		{
			NodeIndex = treeObj.getNodeIndex(Node);
			treeObj.removeNode(Node);
		}
		console.log(NodeIndex);
		return NodeIndex;
    }
</script>

<script>
	//上传进度框显示控制
	$(".el-upload-list").delegate(".closeBtn","click",function(){
		var uploadStatus = DocUpload.getUploadStatus();
		//uploadStatus = "busy";
		console.log("uploadStatus:" + uploadStatus);
		if(uploadStatus == "busy")
	    {
			qiao.bs.confirm({
		        id: 'bsconfirm',
		        msg: '上传还未结束，是否终止上传！'
		    },function(){
		        //alert('点击了确定！');
		    	DocUpload.stopAllUpload();
		    },function(){
		        //alert('点击了取消！');
		    });
	    }
	    else
	    {
	    	$(".el-upload-list").hide();
	    }
	});
	
	var showUploadList = true;
	$(".el-upload-list").delegate(".upload-list-title","click",function(){
		if(showUploadList == true)
		{
			showUploadList = false;
			//收起进度
			var height = - $(".el-upload-list").height()+"px";
			$(".el-upload-list").animate({bottom: height});
			$(".closeBtn").animate({opacity: 0});	//隐藏关闭按键
			//$(this).animate({opacity: 0});	//隐藏title，好像title不应该隐藏
		}
		else
		{
			showUploadList = true;
			$(".el-upload-list").animate({bottom: "0px"});
			$(".closeBtn").animate({opacity: 1});	//显示关闭按键
			//$(this).animate({opacity: 1});	//this 指向的是title，显示title
		}
	});
	
	/* 上传进度放在目录树的实现，不友好，代码放这里是可能给其他实现作参考
	$('.lookPro').on('click',function(){
		$(".el-upload-list").show();
		$('.main').removeClass('active');
		$(this).addClass('active');
	});
	$('.main').on('click',function(){
		$(".el-upload-list").hide();
		$('.lookPro').removeClass('active');
		$(this).addClass('active');
	});
	*/
	
    var zTree = jQuery.fn.zTree;

    $(document).keydown(function(e){
        // ctrl + s
        if( e.ctrlKey  == true && e.keyCode == 83 ){

            return false;
        }
    });

    // 从 url 中获取参数
    function getQueryString(name) {
        var reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');
        var r = window.location.search.substr(1).match(reg);
        if (r != null) {
            return unescape(r[2]);
        }
        return null;
    }

	function getTime() {
        var now= new Date(),
        h=now.getHours(),
        m=now.getMinutes(),
        s=now.getSeconds(),
        ms=now.getMilliseconds();
        return (h+":"+m+":"+s+ " " +ms);
    }

</script>


<script type="text/javascript">



    var events = $("body");
    var catalog = null;
    /**
     * 初始化高亮插件
     */
    function initHighlighting() {
        $('pre code').each(function (i, block) {
            hljs.highlightBlock(block);
        });

        hljs.initLineNumbersOnLoad();
    }
    $(function () {
        initHighlighting();

        var windowHeight = $(window).height();
        var bodyHeight = $(document).height();

        $(window).resize(function(){
            var windowHeight = $(window).height();
            var bodyHeight = $(document).height();
        });

        /*
         catalog = $("#sidebar").jstree({
         'plugins':["wholerow","types"],
         "types": {
         "default" : {
         "icon" : false  // 删除默认图标
         }
         },
         'core' : {
         'check_callback' : false,
         "multiple" : false ,
         'animation' : 0
         }
         }).on('select_node.jstree',function (node,selected,event) {
         $(".m-manual").removeClass('manual-mobile-show-left');
         var url = selected.node.a_attr.href;

         if(url == window.location.href){
         return false;
         }


         $.ajax({
         url : url,
         type : "GET",
         beforeSend :function (xhr) {
         var body = events.data('body_' + selected.node.id);
         var title = events.data('title_' + selected.node.id);
         var doc_title = events.data('doc_title_' + selected.node.id);

         if(body && title && doc_title){

         $("#page-content").html(body);
         $("title").text(title);
         $("#article-title").text(doc_title);

         events.trigger('article.open',url,true);

         return false;
         }
         NProgress.start();
         },
         success : function (res) {
         if(res.errcode == 0){
         var body = res.data.body;
         var doc_title = res.data.doc_title;
         var title = res.data.title;

         $("#page-content").html(body);
         $("title").text(title);
         $("#article-title").text(doc_title);

         events.data('body_' + selected.node.id,body);
         events.data('title_' + selected.node.id,title);
         events.data('doc_title_' + selected.node.id,doc_title);

         events.trigger('article.open',url,false);

         }else{
         layer.msg("加载失败");
         }
         },
         complete : function () {
         NProgress.done();
         }
         });
         });*/

        $("#slidebar").on("click",function () {
            $(".m-manual").addClass('manual-mobile-show-left');
        });
        $(".manual-mask").on("click",function () {
            $(".m-manual").removeClass('manual-mobile-show-left');
        });
    });

    events.on('article.open', function (event, url,init) {
        if ('pushState' in history) {

            if (init == false) {
                history.replaceState({}, '', url);
                init = true;
            } else {
                history.pushState({}, '', url);
            }

        } else {
            location.hash = url;
        }
        initHighlighting();

    });

</script>


<script type="text/javascript">
	/******************************** Repos Interfaces***************************************/
    function getReposInfo(callback){
		console.log("getReposInfo");
        $.ajax({
            url : "/DocSystem/Repos/getRepos.do",
            type : "post",
            dataType : "json",
            data : {
                vid:gReposId
            },
            success : function (ret) {
                if( "ok" == ret.status ){
                	gReposInfo = ret.data;
                    gReposType = gReposInfo.type;
                    gReposName = gReposInfo.name;
                    gReposCreateTime = gReposInfo.createTime;
                    $("#projectName").text(gReposName);
                    //$("#editTime").text(gReposCreateTime);
                    if(gReposType == 0)
                    {
                    	//alert("虚拟文件系统");
                        var keep = {};	//将虚拟文件系统的isParent锁定属性去掉
            			setting.data.keep = keep;
					}
					//回调函数	
                    callback && callback();
                }else {
                    $("#projectName").text("仓库名");
                    alert(ret.msgInfo);
                    window.location.href = "index.html";
                }
            },
            error : function () {
                showErrorMessage("服务器异常:获取仓库信息失败");
            }
        });

    }

	//从后台获取zTree数据: callback1是成功后的回调函数1，需要后续处理的话加在这里处理
	function getMenu(callback1,callback2) {
		//console.log("getMenu callback1:" +callback1 + " callback2:" + callback2);
		$.ajax({
		    url : "/DocSystem/Repos/getReposInitMenu.do",
		    type : "post",
		    dataType : "json",
		    data : {
		    	docId: gDocId,
		        vid : gReposId,      
		    },
		    success : function (ret) {
		        	if( "ok" == ret.status ){
		        		console.log("getMenu() ret",ret);
		                callback1 && callback1(ret.data);
		                callback2 && callback2();
		            }
		            else
		           	{
		           		showErrorMessage("Error:getReposMenu failed" + ret.MsgInfo);
		           	}
		        },
		        error : function () {
		            showErrorMessage("服务器异常:getReposMenu failed" + ret.MsgInfo);
		        }
		    });
	}

	/******************************** Doc Interfaces***************************************/
	//文件保存操作: callback是指成功后的回调函数
    function saveDoc(curDocId, content,newDocId){
		console.log("saveDoc curDocId:" + curDocId + " newDocId" + newDocId);
        $.ajax({
            url : "/DocSystem/Doc/updateDocContent.do",
            type : "post",
            dataType : "json",
            data : {
                id : curDocId,
                content : content
            },
            success : function (ret) {
                if( "ok" == ret.status ){
                    console.log("保存成功 : " , (new Date()).toLocaleDateString());
                    bootstrapQ.msg({
								msg : "保存成功 :" + (new Date()).toLocaleDateString(),
								type : 'success',
								time : 1000,
					});
					//清除debounce
					debounce.clear();
					
					if(newDocId)
					{
						unlockAndExitEditWiki(curDocId,newDocId);
					}
				}else {
                    bootstrapQ.alert("保存失败:"+ret.msgInfo);
                }
            },
            error : function () {
                bootstrapQ.alert("保存失败:服务器异常");
            }
        });

    }
    
    //文件临时保存操作
    function tmpSaveDoc(id, content){
		console.log("tmpSaveDoc: " + content);
        $.ajax({
            url : "/DocSystem/Doc/tmpSaveDocContent.do",
            type : "post",
            dataType : "json",
            data : {
                id : id,
                content : content
            },
            success : function (ret) {
                if( "ok" == ret.status ){
                    console.log("临时保存成功 :" , (new Date()).toLocaleDateString());
                    bootstrapQ.msg({
								msg : "临时保存成功 :" + (new Date()).toLocaleDateString(),
								type : 'success',
								time : 1000,
					});
                }else {
                    //bootstrapQ.alert("临时保存失败:"+ret.msgInfo);
                    bootstrapQ.msg({
						msg : "临时保存失败 :" + +ret.msgInfo,
						type : 'danger',
						time : 1000,
					});
                }
            },
            error : function () {
                //bootstrapQ.alert("临时保存异常");
                bootstrapQ.msg({
					msg : "临时保存失败 :服务器异常",
					type : 'danger',
					time : 1000,
				});
            }
        });

    }
    
    function updateUrl(reposId,docId,edit)
    {
        //Update URL 保证页面刷新后还是处于正确的状态
        var param = {
        	vid : reposId,
            doc : docId,
            edit: edit,
        };
        var url = makeUrl(param);
		window.history.pushState({}, "wiki", url);
	}

	//读取文件信息
    function getDoc(docId,edit) {
      	console.log("getDoc() docId:"+docId + " edit:" + edit);
      	
      	//To get the Doc  
        $.ajax({
            url : "/DocSystem/Doc/getDoc.do",
            type : "post",
            dataType : "json",
            data : {
                id : docId,
            },
            success : function (ret) {
                if( "ok" == ret.status ){
                	console.log("getDoc ret",ret);
                	$('.filetitle').html(ret.data.name);
                    gDocId = ret.data.id;
                    if(ret.data.content == "null")
                    {
                    	gDocContent = "";	//Convert it to empty String
                    }
                    else
                    {	
                    	gDocContent = JSON.parse(ret.data.content);
                    }
                    
					//Update URL 保证页面刷新后还是处于正确的状态
					updateUrl(gReposId,gDocId,edit);
					
					DocEdit.loadmd(gDocContent,edit);
                    
                    WikiEditBtnCtrl(edit);		
					
                    //we need to clear debounce when a new doc was loaded
					debounce.clear();
					if(edit)
					{
						//start the autoTmpSaver
						DocEdit.startAutoTmpSaver();
					}
					else
					{
						DocEdit.stopAutoTmpSaver();
					}
                }
                else
                {
                	showErrorMessage("获取文件信息失败：" + ret.msgInfo);              	
                }
            },
            error : function () {
                showErrorMessage("获取文件信息失败：服务器异常");
                $btn.button('reset');
            }
        });
    }
	
	function showDocHistory()
	{
		console.log("showDocHistory()");

		var parentPath ="";
		var docName = "";

		var treeNode = curRightClickedTreeNode;
		if(treeNode != null)
		{
			parentPath = getTreeNodeParentPath(treeNode);
			docName = treeNode.name;
		}
		console.log("parentPath:" + parentPath + " docName:"+docName);
		
		//show HistoryLogs page
		bootstrapQ.dialog({
			title: "文件历史",
			url: 'historyLogs.html',
			msg: '页面正在加载，请稍等...',
			foot: false,
			big: true,
			callback: function(){
				historyLogsPageInit(gReposId,parentPath,docName);
			},
		});
	}
	
	function getTreeNodeFullPath(treeNode)
	{
		console.log("getTreeNodeFullPath treeNode",treeNode);
		
		var parentPath = "";
		
		var nodes = treeNode.getPath();
		console.log("getTreeNodeFullPath nodes",nodes);
		for(var i=0;i<nodes.length-1;i++)
		{
			parentPath = parentPath + nodes[i].name + "/";
		}
		return parentPath + treeNode.name;
	}
	
	
	function getTreeNodeParentPath(treeNode)
	{
		console.log("getTreeNodeParentPath treeNode",treeNode);
		
		var parentPath = "";
		
		var nodes = treeNode.getPath();
		console.log("getTreeNodeParentPath nodes",nodes);
		for(var i=0;i<nodes.length-1;i++)
		{
			parentPath = parentPath + nodes[i].name + "/";
		}
		return parentPath;
	}
	
	//getDocHistory接口
	function getDocHistory(docPath,reposId)
	{
   		console.log("getHistory docPath:" + docPath + " reposId:" +  reposId);
    	$.ajax({
             url : "/DocSystem/Doc/getDocHistory.do",
             type : "post",
             dataType : "json",
             data : {
             	docPath : docPath,
                reposId : reposId, 
             },
             success : function (ret) {
             	if( "ok" == ret.status){
        		  	console.log(ret.data);
					bootstrapQ.msg({
								msg : "获取历史信息成功！",
								type : 'success',
								time : 2000,
					});
                }
                else
                {
                	showErrorMessage("获取历史信息失败:" + ret.msgInfo);
                }
            },
            error : function () {
                showErrorMessage("获取历史信息失败:服务器异常");
            }
        });
	}
	
   	//addDoc接口	
   	function addDoc(name,type,content,parentNode,parentId,vid)
   	{
   		console.log("addDoc name:" + name + " type:" +  type + " content:" +  content + " parentNode:" +  parentNode + " vid:" +  vid);
    	$.ajax({
             url : "/DocSystem/Doc/addDoc.do",
             type : "post",
             dataType : "json",
             data : {
             	name : name,
             	content: content,
                type : type, //文件类型
                reposId : vid, 
                parentId : parentId,
             },
             success : function (ret) {
             	if( "ok" == ret.status && ret.data.id){
             		if(type == 2)
                    {
                    	isParent = true;
                    }
                    else
                    {
                    	isParent = false;                    	
                    }
                    addTreeNode(name,isParent,ret.data.id,parentNode);
             		// 普通消息提示条
					bootstrapQ.msg({
								msg : "新建完成！",
								type : 'success',
								time : 2000,
					});
                }
                else
                {
                	showErrorMessage("新建失败:" + ret.msgInfo);
                }
            },
            error : function () {
                showErrorMessage("新建失败:服务器异常！");
            }
        });
    }
    
    //renameDoc接口
    function renameDoc(id,newName)
    {
    	console.log("renameDoc id:" + id + " newName:" +  newName);
        $.ajax({
                url : "/DocSystem/Doc/renameDoc.do",
                type : "post",
                dataType : "json",
                data : {
                    id : id,
                    newname: newName,
                },
                success : function (ret) {
                    if( "ok" == ret.status ){
                        //updateMenu();
                        bootstrapQ.msg({
								msg : "重命名完成！",
								type : 'success',
								time : 2000,
						});
                    }
                    else
                    {
                    	syncUpMenu();
                    	showErrorMessage("重命名失败:" + ret.msgInfo);
                    }
                },
                error : function () {
	               syncUpMenu();
 	               showErrorMessage("重命名失败:服务器异常！");
                }
        });
    }
    
	//DocDelete类
    var DocDelete = (function () {
    	var busy = 0;
    	
        //deleteDoc current conditions
        var treeNodes = null; //doc nodes which need to be delete
        var index = 0;  //current delete node index in treeNodes
        var totalNum = 0; //total nums of treeNodes
        var status = 0;  //deleteDoc使用状态机实现，子目录的递归复制，0表示当秦index指向的treeNode是第一次进来，1表示第二次进来，第二次进来的话，不需要再检查其子目录
        
        //Context Cache: 用于deleteDoc的子目录复制操作的递归实现（利用上下文堆栈实现copyDoc的异步递归实现）
        var indexCache = [];
        var treeNodesCache =[];
        var totalNumCache = [];
        var statusCache =[];
        
        //标准Java成员操作接口
		function getIndex()
		{
            return index;
		}
		
		function setIndex(i)
		{
			index = i;
		}
		
		function getTreeNodes()
		{
            return treeNodes;
		}
		
		function setTreeNodes(nodes)
		{
			treeNodes = nodes;
		}
		
		function getTotalNum()
		{
            return totalNum;
		}
		
		function setTotalNum(num)
		{
			totalNum = num;
		}
		
		//上下文操作接口
		function pushContext()
		{
			indexCache.push(index);
			treeNodesCache.push(treeNodes);
			totalNumCache.push(totalNum);
			statusCache.push(status);
		}
		function popContext()
		{
			index = indexCache.pop();
			treeNodes = treeNodesCache.pop();
			totalNum = totalNumCache.pop();
			status = statusCache.pop();
		}
		function clearContext()	//清空上下文，出错时需要清空，避免下次进来是被pop out来执行
		{
			indexCache = [];
	        treeNodesCache =[];
	        totalNumCache = [];
	        statusCache = [];
	    }
		function ContextSize()
		{
			return indexCache.length;
		}
		
		//多文件Delete接口
		function deleteDocs(treeNodes,parentNode,vid)	//多文件移动函数
		{
			console.log("deleteDocs");
			if(busy ==  1)
			{
				bootstrapQ.alert("系统正忙，请稍候重试！");
				return;
			}
			
			busy = 1;
			clearContext();	//清空Context缓存
			
			DocDeleteSet(treeNodes,parentNode,vid);	//设置DocCopy Parameters
				
			//启动删除操作      		
			deleteDoc();	//start delete
		}
		
      	//初始化deleteDoc conditions
      	function DocDeleteSet(treeNodes)	//多文件移动函数
		{
			console.log("DocDeleteSet");

			setIndex(0);
			setTreeNodes(treeNodes);
			var totalNum = 0;
			if(treeNodes && treeNodes.length)
			{
				totalNum = treeNodes.length;
			}
			setTotalNum(totalNum);
			status = 0;
		}
      		
		//deleteDoc接口，该接口是个递归调用
		function deleteDoc()
		{
			var treeNode = treeNodes[index];
			console.log("deleteDoc index:" + index + " name:" + treeNode.name + " totalNum:" + totalNum);
			
			//后台会自动删除子目录，因此前台不需要遍历删除其子目录
			//if(doDeleteSubDocs() == true)
			//{
			//	return;
			//}
			
			$.ajax({
                url : "/DocSystem/Doc/deleteDoc.do",
                type : "post",
                dataType : "json",
                data : {
                    id : treeNode.id,
                },
	            success : function (ret) {
	                if( "ok" == ret.status ){
	                	console.log(ret.data);
	                 	//后台删除成功
	                    var treeObj = $.fn.zTree.getZTreeObj("doctree");
				     	treeObj.removeNode(treeNode);
				     	
				     	//start to delete nextDoc
				     	deleteNextDoc();
				     	return;
	                }
	                else
	                {
	                	console.log("Error:" + ret.msgInfo);
	                	deleteErrorConfirm(treeNode.name,ret.msgInfo);
	            		return;
	                }
	            },
	            error : function () {
	             	console.log("服务器异常：delete failed");
	             	deleteErrorConfirm(treeNode.name,"服务器异常");
	            	return;
	            }
	    	});
		}
		
      	function deleteErrorConfirm(FileName,errMsg)
      	{
      		var msg = FileName + "删除失败,是否删除复制其他文件？";
      		if(errMsg != undefined)
      		{
      			msg = FileName + "删除失败(" + errMsg + "),是否继续删除其他文件？";
      		}
      		//弹出用户确认窗口
      		qiao.bs.confirm({
    	    	id: "deleteErrorConfirm",
    	        msg: msg,
    	        close: false,		
    	        okbtn: "继续",
    	        qubtn: "结束",
    	    },function () {
    	    	//alert("点击了确定");
    	    	deleteNextDoc();
    	    	return true;
			},function(){
    	    	//alert("点击了取消");
    	    	busy = 0;
	            clearContext(); //清空上下文
	            //syncUpMenu();	//将新增的失败的节点刷掉
    	    	return true;
      		});
      	}
		
      	//删除子目录
      	function doDeleteSubDocs(treeNode)
      	{
			if(status == 0)
			{
				if(treeNode.isParent)	//如果是parentNode,则获取其子目录先删除掉
	            {
	            	console.log("treeNodes[" + index + "] isParent");
	            	var treeObj = $.fn.zTree.getZTreeObj("doctree");
					var subTreeNodes = treeObj.getNodesByParam("pId", treeNode.id, treeNode);
	            	if(subTreeNodes && subTreeNodes.length)
		      		{
		      			console.log("subTreeNodes num:" + subTreeNodes.length);
		      			//save context to contextStack
		      			//index++; //当前节点还没有被删除，所以index不可以增加哦
		      			status = 1; //但是需要记录该节点是第二次进来，避免再次检查该目录是否为空，理论上本来应该是可以检查的，但是好像获取subTreeNodes有点问题，导致获取到的子节点仍然存在
		      			pushContext();
		      			
		      			//设置新的copyDoc条件
		      			DocDeleteSet(subTreeNodes);
		      			
		      			deleteDoc();	//启动删除子目录
		      			return true;
		      		}
		      		else
		      		{
		      			console.log("subTreeNodes is null");
		      		}
	            }
			}
			return false;
      	}
      	
      	function deleteNextDoc()
      	{
           	//确定是否还有需要删除的文件
           	index++;
           	if(index < totalNum)	//callback没传入，表示单个上传
           	{
           		status = 0;
           		deleteDoc();	//do delete Next Doc	                   	
	      	}
           	else	//更新显示数据
           	{	
           		if(ContextSize() > 0)	//上下文非空
          		{
          			popContext();	//pop out the Context
           			if(index < totalNum)
           			{
           				status = 0;
           				deleteDoc();
					}
					else
					{
		    	    	busy = 0;
			            clearContext(); //清空上下文
			            //syncUpMenu();
			            
						bootstrapQ.msg({
							msg : '删除完成！',
							type : 'success',
							time : 2000,
						});
					}
          		}
          		else
          		{
        	    	busy = 0;
    	            clearContext(); //清空上下文
    	            //syncUpMenu();
    	            
            		bootstrapQ.msg({
						msg : '删除完成！',
						type : 'success',
						time : 2000,
					});
            	}
            }
      	}
      	
		
		//开放给外部的调用接口
        return {
        	deleteDocs: function(treeNodes,parentNode,vid){
        		deleteDocs(treeNodes,parentNode,vid);
            },
        };
    })();
	
	//DocCopy类
    var DocCopy = (function () {
    	
    	//copyDoc conditions
        var index = 0;        //当前操作的索引
        var treeNodes = null;
        var totalNum = 0;
        var parentNode = null;
        var parentId = 0;
        var vid = 0; 

        //Context Cache
        var indexCache = [];
        var treeNodesCache =[];
        var totalNumCache = [];
        var parentNodeCache = [];
        var parentIdCache = [];
        var vidCache = [];
        
        //标准Java成员操作接口
		function getIndex()
		{
            return index;
		}
		
		function setIndex(i)
		{
			index = i;
		}
		
		function getTreeNodes()
		{
            return treeNodes;
		}
		
		function setTreeNodes(nodes)
		{
			treeNodes = nodes;
		}
		
		function getTotalNum()
		{
            return totalNum;
		}
		
		function setTotalNum(num)
		{
			totalNum = num;
		}
		
		function getParentNode()
		{
            return parentNode;
		}
		
		function setParentNode(node)
		{
			parentNode = node;
		}
		
		function getParentId()
		{
            return parentId;
		}
		
		function setParentId(id)
		{
			parentId = id;
		}
		
		function getVid()
		{
            return vid;
		}
		
		function setVid(id)
		{
			vid = id;
		}
		
		
		//上下文操作接口
		function pushContext()
		{
			indexCache.push(index);
			treeNodesCache.push(treeNodes);
			totalNumCache.push(totalNum);
			parentNodeCache.push(parentNode);
			parentIdCache.push(parentId);
			vidCache.push(vid);			
		}
		function popContext()
		{
			index = indexCache.pop();
			treeNodes = treeNodesCache.pop();
			totalNum = totalNumCache.pop();
			parentNode = parentNodeCache.pop();
			parentId = parentIdCache.pop();
			vid = vidCache.pop();
		}
		function clearContext()	//清空上下文，出错时需要清空，避免下次进来是被pop out来执行
		{
			indexCache = [];
	        treeNodesCache =[];
	        totalNumCache = [];
	        parentNodeCache = [];
	        parentIdCache = [];
	        vidCache = [];
		}
		function ContextSize()
		{
			return indexCache.length;
		}
      	
		//提供给外部的多文件copy接口
		function copyDocs(treeNodes,parentNode,vid)	//多文件移动函数
		{
			console.log("copyDocs");
			if(ContextSize() > 0)
			{
				bootstrapQ.alert("系统正忙，请稍候重试！");
				return;
			}
			clearContext();	//清空Context缓存
			
			DocCopySet(treeNodes,parentNode,vid);	//设置DocCopy Parameters
				
			//启动复制操作      		
			copyDoc();	//start copy
		}
		
      	//初始化DocCopy设置
      	function DocCopySet(treeNodes,parentNode,vid)	//多文件移动函数
		{
			console.log("DocCopySet");

			setIndex(0);

			setTreeNodes(treeNodes);
			var totalNum = 0;
			if(treeNodes && treeNodes.length)
			{
				totalNum = treeNodes.length;
			}
			setTotalNum(totalNum);

			setParentNode(parentNode);
			var parentId = 0;
			if(parentNode && parentNode.id)
			{
 				parentId = parentNode.id;
			}
			setParentId(parentId);
			
			setVid(vid);			
      	}
      		
		//copyDoc接口，该接口是个递归调用
		function copyDoc(dstName)
		{
			var treeNode = treeNodes[index];
			console.log("copyDoc index:" + index + " name:" + treeNode.name + " parentId:" + parentId + " vid:" + vid + " totalNum:" + totalNum);
			
			//
			if(treeNode.id == parentId)
			{
				console.log("treeNode is same to parentNode","treeNode",treeNode.id,"parentId",parentId);
				copyErrorConfirm(treeNode.name);
				return;
			}			
			
			var dstDocName = treeNode.name;
			//如果copyDoc未指定dstName,需要检查parentNode下是否存在同名Node
			if(dstName != undefined)
			{
				dstDocName = dstName;	
			}
			else
			{
				if(isNodeExist(treeNode.name,parentNode) == true)
			  	{
			  		//Node Name conflict confirm
					CopyConflictConfirm(treeNode.name);
			  		return;
			  	}
			}
			
			$.ajax({
	            url : "/DocSystem/Doc/copyDoc.do",
	            type : "post",
	            dataType : "json",
	            data : {
	                id : treeNode.id,	//待复制的docid
	                dstPid: parentId,	//目标doc parentId
	                dstDocName: dstDocName, //目标docName
	                vid: vid,			//仓库id
	            },
	            success : function (ret) {
	                if( "ok" == ret.status ){
	                	console.log(ret.data);
	                 	//后台复制成功，根据后台返回的docid,新建一个treeNode
						var newNode = {name: ret.data.name,id : ret.data.id, pId: ret.data.pid, isParent: ret.data.type==2?true:false};
	                 	var treeObj = $.fn.zTree.getZTreeObj("doctree");
						var NodeIndex =  -1;
	          			treeObj.addNodes(parentNode,NodeIndex,newNode);
	          			var newTreeNode = treeObj.getNodeByParam("id", ret.data.id,parentNode);
	          			console.log(newTreeNode.name);          			

	          			//后台将自动复制其子目录，因此前台不需要遍历复制其子目录
	          			//if(doCopySubDocs(treeNode) == true)	//如果是parentNode,则获取其子目录
	                    //{
	          			//	return;
	                    //}
	          			
	          			//复制下一个Doc
	                    copyNextDoc();
	                }
	                else
	                {
	                	console.log("Error:" + ret.msgInfo);
	                	copyErrorConfirm(treeNode.name,ret.msgInfo);
	                	return;
	                }
	            },
	            error : function () {
	            	console.log("服务器异常：copy failed");
                	copyErrorConfirm(treeNode.name,"服务器异常");
                	return;
	            }
	    	});
		}
		
		function doCopySubDocs(treeNode)
		{
  			if(treeNode.isParent)	//如果是parentNode,则获取其子目录
            {
            	console.log("treeNodes[" + index + "] isParent");
            	var subTreeNodes = treeObj.getNodesByParam("pId", treeNode.id, treeNode);
            	if(subTreeNodes && subTreeNodes.length)
	      		{
	      			console.log("subTreeNodes num:" + subTreeNodes.length + " newTreeNode:" + newTreeNode.name);
	      			//保存上下文
	      			index++;
	      			pushContext();
	      			//设置新的copyDoc条件
	      			DocCopySet(subTreeNodes,newTreeNode,vid);
	      			return true;
	      		}
	      		else
	      		{
	      			console.log("subTreeNodes is null");
	      		}
            }
  			return false;
		}
		
		//启动复制下一个Doc,如果没有了的话则结束复制
		function copyNextDoc()
		{
           	//确定是否还有需要复制的文件
           	index++;
           	if(index < totalNum)	//callback没传入，表示单个上传
           	{
   				//Start to copy next Doc
	      		copyDoc();	//do copy Next Doc	                   	
	      	}
           	else	//更新显示数据
           	{	
           		if(ContextSize() > 0)	//上下文非空
          		{
          			popContext();	//pop out the Context
           			if(index < totalNum)
           			{
           				//Start to copy next Doc
           				copyDoc();
					}
					else
					{
	        	    	busy = 0;
	    	            clearContext(); //清空上下文
	    	            //syncUpMenu();	//刷新菜单
			            
						bootstrapQ.msg({
							msg : '复制完成！',
							type : 'success',
							time : 2000,
						});
					}
          		}
          		else
          		{
        	    	busy = 0;
    	            clearContext(); //清空上下文
    	            //syncUpMenu();	//刷新菜单
    	            
    	            bootstrapQ.msg({
						msg : '复制完成！',
						type : 'success',
						time : 2000,
					});
            	}
            }
		}
		
		function CopyConflictConfirm(copiedNodeName)
		{
		    qiao.bs.dialog({
		        id: "dialog-copyConflictDialog",
		        url: '#copyConflictConfirmDialog',
		        title: copiedNodeName + '已存在',
    	        //close: false,		
		        okbtn: "确定",
    	        qubtn: "取消",
		        callback: function () {
		            setTimeout(function () {
		                $("#dialog-copyConflictDialog input[name='newDocName']").val("Copy of " + copiedNodeName);
		            },100);
		        }
		    },function () {
		    	//确定按键
		    	var dstName =  $("#dialog-copyConflictDialog input[name='newDocName']").val();
		    	console.log("copyConflictConfirm newName:",dstName);
				copyDoc(dstName);
		    	return true;   
		    });
		}
		
      	function copyErrorConfirm(FileName,errMsg)
      	{
      		var msg = FileName + "复制失败,是否继续复制其他文件？";
      		if(errMsg != undefined)
      		{
      			msg = FileName + "复制失败(" + errMsg + "),是否继续复制其他文件？";
      		}
      		//弹出用户确认窗口
      		qiao.bs.confirm({
    	    	id: "copyErrorConfirm",
    	        msg: msg,
    	        close: false,		
    	        okbtn: "继续",
    	        qubtn: "结束",
    	    },function () {
    	    	//alert("点击了确定");
    	    	copyNextDoc();
    	    	return true;
			},function(){
    	    	//alert("点击了取消");
    	    	busy = 0;
    	        clearContext(); //清空上下文
    	        syncUpMenu();	//刷新菜单
    	    	return true;
      		});
      	}
		
		//开放给外部的调用接口
        return {
			copyDocs: function(treeNodes,parentNode,vid){
            	copyDocs(treeNodes,parentNode,vid);
            },
        };
    })();


	//DocMove类	
    var DocMove = (function () {
    	var busy = 0;
    	
        //moveDoc conditions
    	var index = 0; //当前操作的索引
        var treeNodes = null;
        var totalNum = 0;
        var parentNode = null;
        var parentId = 0;
        var vid = 0; 

        //Context Cache
        var indexCache = [];
        var treeNodesCache =[];
        var totalNumCache = [];
        var parentNodeCache = [];
        var parentIdCache = [];
        var vidCache = [];
        
        //标准Java成员操作接口
		function getIndex()
		{
            return index;
		}
		
		function setIndex(i)
		{
			index = i;
		}
		
		function getTreeNodes()
		{
            return treeNodes;
		}
		
		function setTreeNodes(nodes)
		{
			treeNodes = nodes;
		}
		
		function getTotalNum()
		{
            return totalNum;
		}
		
		function setTotalNum(num)
		{
			totalNum = num;
		}
		
		function getParentNode()
		{
            return parentNode;
		}
		
		function setParentNode(node)
		{
			parentNode = node;
		}
		
		function getParentId()
		{
            return parentId;
		}
		
		function setParentId(id)
		{
			parentId = id;
		}
		
		function getVid()
		{
            return vid;
		}
		
		function setVid(id)
		{
			vid = id;
		}
		
		
		//上下文操作接口
		function pushContext()
		{
			indexCache.push(index);
			treeNodesCache.push(treeNodes);
			totalNumCache.push(totalNum);
			parentNodeCache.push(parentNode);
			parentIdCache.push(parentId);
			vidCache.push(vid);			
		}
		function popContext()
		{
			index = indexCache.pop();
			treeNodes = treeNodesCache.pop();
			totalNum = totalNumCache.pop();
			parentNode = parentNodeCache.pop();
			parentId = parentIdCache.pop();
			vid = vidCache.pop();
		}
		function clearContext()	//清空上下文，出错时需要清空，避免下次进来是被pop out来执行
		{
			indexCache = [];
	        treeNodesCache =[];
	        totalNumCache = [];
	        parentNodeCache = [];
	        parentIdCache = [];
	        vidCache = [];
		}
		function ContextSize()
		{
			return indexCache.length;
		}
      	
		//多文件move接口
		function moveDocs(treeNodes,parentNode,vid)	//多文件移动函数
		{
			console.log("moveDocs");

			if(busy == 1)
			{
				bootStrapQ("系统正忙，请稍候重试!");
				return;
			}
			busy = 1;
			clearContext();	//清空Context缓存
			
			DocMoveSet(treeNodes,parentNode,vid);	//设置DocMove Parameters
				
			//启动复制操作      		
			moveDoc();	//start move
		}
		
      	//初始化DocMove设置
      	function DocMoveSet(treeNodes,parentNode,vid)	//多文件移动函数
		{
			console.log("DocMoveSet");

			setIndex(0);

			setTreeNodes(treeNodes);
			var totalNum = 0;
			if(treeNodes && treeNodes.length)
			{
				totalNum = treeNodes.length;
			}
			setTotalNum(totalNum);

			setParentNode(parentNode);
			var parentId = 0;
			if(parentNode && parentNode.id)
			{
 				parentId = parentNode.id;
			}
			setParentId(parentId);
			
			setVid(vid);			
      	}
      		
		//moveDoc接口，该接口是个递归调用
    	function moveDoc()
    	{
    		console.log("moveDoc index:" + index + " totalNum:" + totalNum + " parentId:" + parentId + " vid:" + vid);
    		var treeNode = treeNodes[index];
    		
  	    	if(treeNode.pid == parentId)
  			{
  	    		console.log("treeNode is already under parentNode","treeNode",treeNode.pid,"parentNode",parentNode.id);
  	    		//moveErrorConfirm(treeNode.name);
  	    		moveNextDoc();
  	    		return; 
  			}
  	    	
			//执行后台moveDoc操作
    		$.ajax({
                url : "/DocSystem/Doc/moveDoc.do",
                type : "post",
                dataType : "json",
                data : {
                    id : treeNode.id,
                    dstPid: parentId,
                    vid: vid,
                },
                success : function (ret) {
                   if( "ok" == ret.status )
                   {
                	   //moveNextDoc
                	   moveNextDoc();
                	   return;
                   }
                   else	//后台报错，结束移动
                   {
                	   console.log("moveDoc Error:" + ret.msgInfo);
                       moveErrorConfirm(treeNode.name,ret.msgInfo);
                       return;
                   }
                },
                error : function () {	//后台异常
 	               console.log("服务器异常：文件[" + index + "]移动异常！");
            	   moveErrorConfirm(treeNode.name,"服务器异常");
            	   return;
                }
        	});
    	}

		function moveNextDoc()
		{
	        index++;	//move成功，则调用回调函
	        if(index < totalNum) //上传没结束，且回调函数存在则回调，否则表示结束
	        {
	        	console.log("moveDoc Next");
	        	moveDoc();
	        }
	        else	//上传结束，保存目录结构到后台
	        {
    	    	busy = 0;
	            clearContext(); //清空上下文
	            //syncUpMenu();	//刷新菜单
	            
	         	console.log("moveDoc End");
				bootstrapQ.msg({
					msg : '移动完成！',
					type : 'success',
					time : 2000,
				});
	        }
		}
		
      	function moveErrorConfirm(FileName,errMsg)
      	{
      		var msg = FileName + "移动失败,是否继续移动其他文件？";
      		if(errMsg != undefined)
      		{
      			msg = FileName + "移动失败(" + errMsg + "),是否继续移动其他文件？";
      		}
      		//弹出用户确认窗口
      		qiao.bs.confirm({
    	    	id: "moveErrorConfirm",
    	        msg: msg,
    	        close: false,		
    	        okbtn: "继续",
    	        qubtn: "结束",
    	    },function () {
    	    	//alert("点击了确定");
    	    	moveNextDoc();
    	    	return true;
			},function(){
    	    	//alert("点击了取消");
        	    busy = 0;
    	        clearContext(); //清空上下文
    	        syncUpMenu();	//刷新菜单
    	    	return true;
      		});
      	}
		
		//开放给外部的调用接口
        return {
            moveDocs: function(treeNodes,parentNode,vid){
            	moveDocs(treeNodes,parentNode,vid);
            },
        };
    })();
</script>

<script type="text/javascript">
	/********************* 文件编辑接口 *********************************************/
		//如果需要看懂下面的代码，请先看懂seajs，还不懂可以联系我：QQ：652055239
	//load editormd by using seajs
	seajs.config({
        base  : "./static",
        alias : {
            jquery: "scripts/jquery.min.js",
            editormd : "markdown/editormd.js"
        }
    });

    //seajs.use("./js/seajs-main"); //使用main.js时 editormd 路径要改为 "../../editormd"

    var deps = [
        "jquery",
        "editormd",
        "markdown/plugins/link-dialog/link-dialog",
        "markdown/plugins/reference-link-dialog/reference-link-dialog",
        "markdown/plugins/image-dialog/image-dialog",
        "markdown/plugins/code-block-dialog/code-block-dialog",
        "markdown/plugins/table-dialog/table-dialog",
        "markdown/plugins/emoji-dialog/emoji-dialog",
        "markdown/plugins/goto-line-dialog/goto-line-dialog",
        "markdown/plugins/help-dialog/help-dialog",
        "markdown/plugins/html-entities-dialog/html-entities-dialog",
        "markdown/plugins/preformatted-text-dialog/preformatted-text-dialog"
    ];

    seajs.request("static/markdown/css/add.css",function(){});
    
    seajs.use(deps, function($, editormd) {
       	DocEdit.init(editormd);
    });
    
	//DocEdit类	
    var DocEdit = (function () {
    	//markdow Editor
    	var mdEditor;	//editormd构建函数 
    	var md;	//mdeditor对象
    	var firstcall = true;
      	//自动保存定时器
      	var autoSaveTimer;
      	var timerState = 0;
    
    	function init(editor)
      	{
      		console.log("DocEdit init");
      		mdEditor = editor;
      	} 

      	function editorInit(content,edit)
      	{
      		console.log("DocEdit editorInit");
      		gEdit = edit;

      		var params = {
               width: "100%",
               height: $(document).height() - 70,
               path : 'static/markdown/lib/',
               markdown : content,
               //toolbar  : false,             // 关闭工具栏
               codeFold : true,
               searchReplace : true,
               saveHTMLToTextarea : true,      // 保存 HTML 到 Textarea
               htmlDecode : "style,script,iframe|on*",            // 开启 HTML 标签解析，为了安全性，默认不开启
               emoji : true,
               taskList : true,
               tocm: true,          			// Using [TOCM]
               tex : true,                      // 开启科学公式 TeX 语言支持，默认关闭
               //previewCodeHighlight : false,  // 关闭预览窗口的代码高亮，默认开启
               flowChart : true,                // 疑似 Sea.js与 Raphael.js 有冲突，必须先加载 Raphael.js ，Editor.md 才能在 Sea.js 下正常进行；
               sequenceDiagram : true,          // 同上
               //dialogLockScreen : false,      // 设置弹出层对话框不锁屏，全局通用，默认为 true
               //dialogShowMask : false,     // 设置弹出层对话框显示透明遮罩层，全局通用，默认为 true
               //dialogDraggable : false,    // 设置弹出层对话框不可拖动，全局通用，默认为 true
               //dialogMaskOpacity : 0.4,    // 设置透明遮罩层的透明度，全局通用，默认值为 0.1
               //dialogMaskBgColor : "#000", // 设置透明遮罩层的背景颜色，全局通用，默认为 #fff
               imageUpload : true,
               imageFormats : ["jpg", "jpeg", "gif", "png", "bmp", "webp"],
               imageUploadURL : "",
               onchange : function () {
                   console.log("onchange");
                   var newContent = this.getMarkdown();
                   if(gEdit == true)
                   {
            	       debounce.call(newContent);
    		       }
    		       else
    		       {
    		           debounce.clear();
    		       }       
               },
               onpreviewing : function () {
                   console.log("onpreviewing");
                   gEdit = false;
                   WikiEditBtnCtrl(gEdit);
               },
               onpreviewed :function () {
                   console.log("onpreviewed");
               },
               onload : function () {
                   console.log("onload edit:" + edit);
                   if(edit == false)
                   {
                   		this.previewing();               
                   }
                   gEdit = edit;
                   WikiEditBtnCtrl(gEdit);
               }
       		};
       		
       		if(!mdEditor)
       		{
       			showErrorMessage("please load the editormd firstly by seajs");
       			return;
       		}
       		else
       		{
       			md = mdEditor("doc",params);
       		}    
      	}
        
    	function editorLoadmd(content,edit) 
    	{
    		console.log("DocEdit editorLoadmd() edit:" + edit);
    		if(!md)
       		{
    			showErrorMessage("please call editorInit firstly");
       			return;
       		}
       		
    		md.setMarkdown(content);
    		if(edit != gEdit)
    		{
    			gEdit = edit;
    			md.previewing();
    		}
        }
        
        function loadmd(content,edit)
        {
			if(firstcall == true)
   			{ 
    			firstcall = false;
         		editorInit(content,edit);	
    		}
    		else
      		{
      			editorLoadmd(content,edit);	                    
			}
        }
		      		
		function editorSwitch(edit)
    	{
    		console.log("DocEdit editorSwitch() edit:"+edit);
    		if(!md)
       		{
    			showErrorMessage("please call editorInit firstly");
       			return;
       		}
       		
    		if(edit != gEdit)
    		{
    		    gEdit = edit;
    			md.previewing();
    		}
    	}
    	
    	function startAutoTmpSaver()
		{ 
			console.log("DocEdit.startAutoTmpSaver timerState:" + timerState);
			if(timerState == 0)
			{
				timerState = 1;
				autoSaveTimer = setInterval(function () {
		        	if(debounce.getStatus1() == 1)
		    		{
		    			console.log("autoTmpSaveWiki");
		    	    	debounce.clearStatus1();
		    			tmpSaveDoc(gDocId, debounce.get());
		    		}
		    	},20000);
		    }
		}     
	
		function stopAutoTmpSaver(){
			console.log("DocEdit.stopAutoTmpSaver timerState:" + timerState);
			if(timerState == 1)
			{
				timerState = 0;
				clearInterval(autoSaveTimer);
			}
		}

		//开放给外部的调用接口
        return {
            init: function(editor){
            	init(editor);
            },
            loadmd: function(content,edit){
               loadmd(content,edit);
            },
            editorSwitch: function(edit){
            	editorSwitch(edit);
            },
            startAutoTmpSaver: function(){
            	startAutoTmpSaver();
            },
            stopAutoTmpSaver: function(){
            	stopAutoTmpSaver();
            },
            
        };
    })();
	
	//退出文件编辑状态
    function exitEdit(curDocId,newDocId) {
    	console.log("exitEdit curDocId:" + curDocId + " newDocId:" + newDocId);
    	if(!curDocId)
    	{
    		curDocId = gDocId;
    	}
    	
    	if(debounce.getStatus() == 1)
    	{
    		qiao.bs.confirm({
  	 	    		id: 'saveDocConfirm',
  	 	    		msg: "修改未保存，是否保存？",
  	 	    		close: false,		
  	 	    		okbtn: "保存",
  	 	    		qubtn: "直接退出",
  	 	    	},function () {
  	 	    	    saveWikiAndExit(curDocId,newDocId);
  	  	 			return true;
  	 			},function(){
  	 				unlockAndExitEditWiki(curDocId,newDocId);
  	 				return true;
  	 		});
  	 	}
  	 	else
  	 	{
    		unlockAndExitEditWiki(curDocId,newDocId);
    	}
	}
	
	    //将编辑中的文件保存到后台
    function saveWikiAndExit(curDocId,newDocId) {
    	console.log("saveWikiAndExit  curDocId:" + curDocId + " newDocId:" + newDocId);
    	if(debounce.getStatus() == 1)
    	{
    		saveDoc(gDocId, debounce.get(),newDocId);
    	}
    }
	
	function unlockAndExitEditWiki(curDocId,newDocId)
	{
		console.log("unlockAndExitEditWiki()  curDocId:" + curDocId + " newDocId:" + newDocId);
		$.ajax({
			url : "/DocSystem/Doc/lockDoc.do",
			type : "post",
			dataType : "json",
			data : {
				lockType : 0, //unlock the doc
				reposId : gReposId, 
				docId : curDocId,
			},
			success : function (ret) {
				if( "ok" == ret.status){
					console.log(ret.data);
				    exitEditWiki(curDocId,newDocId);
				    return;
 				}
				else
				{
					showErrorMessage("unlockDoc Error:" + ret.msgInfo);
					exitEditWiki(curDocId,newDocId);
					return;
				}
			},
			error : function () 
			{
				showErrorMessage("unlockDoc 异常");
				exitEditWiki(curDocId,newDocId);
				return;
			}
		});
	}
	
    function exitEditWiki(curDocId,newDocId) {  
      	console.log("exitEditWiki()  curDocId:" + curDocId + " newDocId:" + newDocId);
		//swith to preview state
        DocEdit.editorSwitch(false);
        //编辑等按键显示控制
        WikiEditBtnCtrl(false);
	    
	    //Stop autoSaver
	    debounce.clear();
	    DocEdit.stopAutoTmpSaver();
	            
        if(newDocId)
        {
        	var edit = false;
        	getDoc(newDocId,edit);	//
        }
        else
        {
	        //更新URL(保证页面刷新后能够)
		    var params = {
	            vid : gReposId,
	            doc : curDocId,
	        }
	        var url = makeUrl(params);
	        window.history.pushState({}, "wiki", url);	//just update the url,do not reload the page	
        }
    }
	
	//进入编辑状态
	function lockAndEditWiki()
	{
		console.log("lockAndEditWiki()");
		var vid = gReposId;
		var docId = gDocId;

		$.ajax({
			url : "/DocSystem/Doc/lockDoc.do",
			type : "post",
			dataType : "json",
			data : {
				lockType : 3, //
				reposId : vid, 
				docId : docId,
			},
			success : function (ret) {
				if( "ok" == ret.status){
					console.log(ret.data);
				    editWiki(docId);
				    return;
 				}
				else
				{
					showErrorMessage("lockDoc Error:" + ret.msgInfo);
					return;
				}
			},
			error : function () 
			{
				showErrorMessage("lockDoc 异常");
				return;
			}
		});
	}
	
	//进入文件编辑状态
    function editWiki(docId){
        
        DocEdit.editorSwitch(true);
        
        WikiEditBtnCtrl(true);
	    
        var params = {
            vid : gReposId,
            doc : docId,
            edit : true,
        }
        var url = makeUrl(params);
        //window.location.href = url;	//reload the page
        window.history.pushState({}, "wiki", url);	//just update the url,do not reload the page
        
        //start the autoTmpSaver
        debounce.clear();
	    DocEdit.startAutoTmpSaver();
    }
    
    //将编辑中的文件保存到后台
    function saveWiki() {
    	console.log("saveWiki");
    	if(debounce.getStatus() == 1)
    	{
    		saveDoc(gDocId, debounce.get());
    	}
    }
	
	//debounce文件编辑缓存类
    var debounce = (function () {
        //var cache = [];
        var latestcopy = "";
        var status = 0; //For save
        var status1 = 0; //For tmpSave
        
		function getLatestCopy()
		{
		    return latestcopy;
		}
		
		function getStatus()
		{
			if ( status == 1 ){	
            	return 1;
            }
            return 0;
		}
		
		function clearStatus()
		{
			status = 0;
		}
		
		function getStatus1()
		{
			if ( status1 == 1 ){	
            	return 1;
            }
            return 0;
		}
		
		function clearStatus1()
		{
			status1 = 0;
		}
		
        return {
            get: function(){
            	return getLatestCopy();
            },
            getStatus: function(){
            	return getStatus();
            },
            getStatus1: function(){
            	return getStatus1();
            },
            clearStatus: function(){
            	console.log("debounce clearStatus");
            	return clearStatus();
            },
            clearStatus1: function(){
	            console.log("debounce clearStatus1");
            	return clearStatus1();
            },
            call : function (c) {
            	console.log("debounce call");
                latestcopy = c;
                status = 1;
                status1 = 1;
            },
            clear : function () {
                console.log("debounce clear");
                status = 0;
                status1 = 0;
                latestcopy = "";
            }
        };
    })();
	
	
    function makeUrl(params) {
        var href = window.location.href;
        var i = href.indexOf("?");
        if ( i< 0 ){
            i = href.length;
        }

        href = href.substring(0,i);

        var str = ""
        for( k in params ){
            if ( params[k] ){ //params[k]
              str += "&" + k + "=" + params[k];

            }

        }


        return href + "?" + str.substr(1);
    }

	function getParam(){
	    var url = location.search; // 获取url中"?"符后的字串
	    if (url.indexOf("?") != -1) { // 判断是否有参数
	        var str = url.substr(1); // 从第一个字符开始 因为第0个是?号 获取所有除问号的所有符串
	        var strs = str.split("="); // 用等号进行分隔 （因为知道只有一个参数 所以直接用等号进分隔 如果有多个参数 要用&号分隔
	        return strs[1]; // 返回第一个参数值
	    }
	
	}

   var getUrlParams = function() {
        "use strict";
        var url = location.search;
        var params = {};
        var strs;
        var _strs;
        if (url.indexOf("?") != -1) {
            var str = url.substr(1);
            if (str.indexOf("&") != -1) {
                strs = str.split("&");
                for ( var i = 0; i < strs.length; i++) {
                    _strs = strs[i].split("=");
                    params[_strs[0]] = _strs[1];
                }
            } else {
                strs = str.split("=");
                params[strs[0]] = strs[1];
            }
        }
        return params;
    }


    //js动态改变url参数值
    function setUrlParam(para_name, para_value) {
        var strNewUrl = new String();
        var strUrl = new String();
        var url = new String();
        url= window.location.href;
        strUrl = window.location.href;
        //alert(strUrl);
        if (strUrl.indexOf("?") != -1) {
            strUrl = strUrl.substr(strUrl.indexOf("?") + 1);
            //alert(strUrl);
            if (strUrl.toLowerCase().indexOf(para_name.toLowerCase()) == -1) {
                strNewUrl = url + "&" + para_name + "=" + para_value;
                window.location = strNewUrl;
                //return strNewUrl;
            } else {
                var aParam = strUrl.split("&");
                //alert(aParam.length);
                for (var i = 0; i < aParam.length; i++) {
                    if (aParam[i].substr(0, aParam[i].indexOf("=")).toLowerCase() == para_name.toLowerCase()) {
                        aParam[i] = aParam[i].substr(0, aParam[i].indexOf("=")) + "=" + para_value;
                    }
                }
                strNewUrl = url.substr(0, url.indexOf("?") + 1) + aParam.join("&");
                //alert(strNewUrl);
                window.location = strNewUrl;
                //return strNewUrl;
            }
        } else {
            strUrl += "?" + para_name + "=" + para_value;
            //alert(strUrl);
            window.location=strUrl;
        }
    }


    function getDate(tm){
        var tt = new Date(tm).toLocaleString();
        return tt;
    }
</script>

<script type="text/javascript" >
//json obj compare
function isObj(object) {
    return object && typeof(object) == 'object' && Object.prototype.toString.call(object).toLowerCase() == "[object object]";
}

function isArray(object) {
    return object && typeof(object) == 'object' && object.constructor == Array;
}

function getLength(object) {
    var count = 0;
    for(var i in object) count++;
    return count;
}

function Compare(objA, objB) {
    if(!isObj(objA) || !isObj(objB)) 
    {
    	console.log("类型不符");
    	return false; //判断类型是否正确
    }
    if(getLength(objA) != getLength(objB)) 
    {
    	console.log("长度不符");
    	return false; //判断长度是否一致
    }
    return CompareObj(objA, objB, true); //默认为true
}

function CompareObj(objA, objB, flag) {
    for(var key in objA) {
        if(!flag) //跳出整个循环
            break;
        if(!objB.hasOwnProperty(key)) {
            flag = false;
            break;
        }
        if(!isArray(objA[key])) { //子级不是数组时,比较属性值
            if(objB[key] != objA[key]) {
                flag = false;
                break;
            }
        } else {
            if(!isArray(objB[key])) {
                flag = false;
                break;
            }
            var oA = objA[key],
                oB = objB[key];
            if(oA.length != oB.length) {
                flag = false;
                break;
            }
            for(var k in oA) {
                if(!flag) //这里跳出循环是为了不让递归继续
                    break;
                flag = CompareObj(oA[k], oB[k], flag);
            }
        }
    }
    return flag;
}
</script>

<script type="text/javascript" src="js/logon.js"></script>
<SCRIPT type="text/javascript" >
	/********************** zTree设置与接口**********************************/
	
	//右键点击所在的zTreeNode：用于右键菜单相关的操作:rename, remove, 新建,上传,下载
	var curRightClickedTreeNode = null;
	var gCopiedNodes = null;	//右键复制操作选中的节点
	
	//zTree's setting
	var setting = {
		//异步加载的工作原理
		async : {  
    		enable : true,//设置 zTree 是否开启异步加载模式  
            url : "/DocSystem/Repos/getSubDocList.do",
            type : "post",
    		autoParam : ["id"],	//zTree会自动根据用户双击的节点设置参数为id=treeId，自动传递的参数必须符合zTree的规则，这也是为什么不得不把后台参数名parentId改为id的原因
    		otherParam:{"vid":gReposId}, //这里设置的参数是固定的，如果需要修改的话需要修改配置文件，我就是这么做的，详见getReposInfo函数	
    		dataFilter: asyncDataFilter, 
		},
	   	//可编辑功能设置
		edit: {
               enable: true,
               removeTitle : "删除",
               renameTitle : "改名",
               showRemoveBtn : false,
               showRenameBtn : false,
               drag: {
                   autoExpandTrigger: true,
                   prev: dropPrev,
                   inner: dropInner,
                   next: dropNext,
               },
           },
           //zTree数据格式
	   	data: {
	   			//使用简单数据模式
	            simpleData: {
	                enable: true,
	            },
	            //不允许修改leaf node and parent node的isParent属性
	            keep: {
	            	leaf: true,
	            	parent: true,
	            },
	    },
	    //zTree各种操作的回调函数定义
	    callback: {
	            beforeAsync: zTreeBeforeAsync, //异步加载前的回调函数， 可以用来判断是否需要异步加载
                onAsyncSuccess: zTreeOnAsyncSuccess, //异步加载完成后的回调
	            beforeDrag: zTreeBeforeDrag,
	            beforeDrop: zTreeBeforeDrop,
	            onDrag : zTreeOnDrag,
	            onDrop : zTreeOnDrop,
	            onChange: zTreeOnChange,
	            onClick: zTreeOnClick,
	            //beforeRemove: zTreeBeforeRemove,	//remove操作将改为主动触发
	            //onRemove: zTreeOnRemove,
	            beforeRename: zTreeBeforeRename,
	            onRename: zTreeOnRename,
	            beforeRightClick: zTreeBeforeRightClick
	            //onRightClick: zTreeOnRightClick, //定义该回调将会屏蔽系统右击事件
	    },
	};


	function asyncDataFilter(treeId, parentNode, responseData) {
		console.log("asyncDataFilter");
		var docList = responseData.data;
		//遍历jason_arry, convert the node type to isParent flag
      	for(var i=0; i<docList.length; i++)
      	{
           var jsonObj = docList[i];
           jsonObj.pId = jsonObj.pid != 0? jsonObj.pid : "root",
           jsonObj.isParent = jsonObj.type == 1? false: true;
       }
       console.log(docList);
	   return docList;
	}
	
    function zTreeBeforeAsync() {  
    	console.log("zTreeBeforeAsync");
    }  
      
    function zTreeOnAsyncSuccess(event, treeId, treeNode, msg) {
    	console.log("zTreeOnAsyncSuccess treeId:" + treeId);
    }

	//This function was used to get the rightClick treeNode,it will be used for contextjs
	function zTreeBeforeRightClick(treeId, treeNode) {
		//alert(treeNode ? treeNode.tId + ", " + treeNode.name : "isRoot");
		curRightClickedTreeNode = treeNode;
    	return true;	
	};
		
	//This function will replace all righot click, so i did not use it
	function zTreeOnRightClick(event, treeId, treeNode) {
    	alert(treeNode ? treeNode.tId + ", " + treeNode.name : "isRoot");
	};
		
	//Drag and Drop Implementation Start: curDragNhodes was used to remember DragNodes
    var className = "dark", curDragNodes, autoExpandNode;        
    //拖动前的检查 
    function zTreeBeforeDrag(treeId, treeNodes) {
        console.log("zTreeBeforeDrag");
        className = (className === "dark" ? "":"dark");
        for (var i=0,l=treeNodes.length; i<l; i++) {
            if (treeNodes[i].drag === false) {	//Current node can not drag
                curDragNodes = null;
                return false;
            } else if (treeNodes[i].parentTId && treeNodes[i].getParentNode().childDrag === false) { //Parent's child can not drag
                curDragNodes = null;
                return false;
            }
        }
        curDragNodes = treeNodes;
        return true;
    }
        
    function zTreeBeforeDragOpen(treeId, treeNode) {
        console.log("zTreeBeforeDragOpen");
        autoExpandNode = treeNode;
        return true;
    }
    
    //zTree拖动处理接口
    function zTreeOnDrag()
    {
    	console.log("zTreeOnDrag");
     	//updateMenu();
    }
        
    //dropPre Next and Inner was use to check if it was allowed to drop
	function dropPrev(treeId, nodes, targetNode) {
		console.log("dropPrev");
           var pNode = targetNode.getParentNode();
           if (pNode && pNode.dropInner === false) {
               return false;
           } else {
           	//当前被拖动的节点和目标节点如果在同一个目录不变化；不同目录，但所在目录子节点不允许移动则不变化
           	var l=curDragNodes.length;
               for (var i=0; i<l; i++) {
                   var curPNode = curDragNodes[i].getParentNode();
                   if (curPNode && curPNode !== targetNode.getParentNode() && curPNode.childOuter === false) {
                       return false;
                   }
               }
           }
           return true;
    }
    function dropInner(treeId, nodes, targetNode) {
      	  console.log("dropInner");
          if (targetNode && targetNode.dropInner === false) {
              return false;
          }
          else {
              //if the curDragNodes was in the same directory with TargetNode do nothing
              for (var i=0,l=curDragNodes.length; i<l; i++) {
                  if (!targetNode && curDragNodes[i].dropRoot === false) {
                      return false;
                  } else if (curDragNodes[i].parentTId && curDragNodes[i].getParentNode() !== targetNode && curDragNodes[i].getParentNode().childOuter === false) {
                      return false;
                  }
              }
          }
          return true;
      }
      function dropNext(treeId, nodes, targetNode) {
      	console.log("dropNext");
          var pNode = targetNode.getParentNode();
          if (pNode && pNode.dropInner === false) {
              return false;
          } else {
              for (var i=0,l=curDragNodes.length; i<l; i++) {
                  var curPNode = curDragNodes[i].getParentNode();
                  if (curPNode && curPNode !== targetNode.getParentNode() && curPNode.childOuter === false) {
                      return false;
                  }
              }
          }
          return true;
      }
		
	  //drop前检查函数
      function zTreeBeforeDrop(treeId, treeNodes, targetNode, moveType, isCopy) {
          console.log("zTreeBeforeDrop");
          
          //move this confirm to dropInner, it will be better
          //if (targetNode && targetNode.isParent !== true) { //leaf node can not drop
          //	console.log("can not drop to leaf node");
          //	return false;
          //}
		            
          if(targetNode.drop === false)
          {
          	console.log("drop was not allowed for this node");
          	return false;
          }
          
          	//get targe parentNode
      		var parentNode = targetNode;
      		if(targetNode)
      		{
      			if(moveType == "prev" || moveType == "next")	//如果拖到节点的前面或后面，则表示要放到上一层目录,leaf的inner属性是通过setting来控制的
      			{
      				parentNode = targetNode.getParentNode();
      			}
      			else
      			{
	      			parentNode = targetNode;
      			}
      		}
      		else
      		{
      			showErrorMessage("targetNode is null,理论上不该出现");
      			return;
      		}
           
          	className = (className === "dark" ? "":"dark");
          	return true;
      }
      
      //Drop处理函数
      function zTreeOnDrop(event, treeId, treeNodes, targetNode, moveType, isCopy)
      {
      		console.log("zTreeOnDrop");
      		
      		if(moveType == null)	//无效拖放，不处理
			{
				//alert("Invalid drag and drop!");
				return;
			}
      		
      		//get targe parentNode
      		var parentNode = targetNode;
      		if(targetNode)
      		{
      			//对于leaf node, prev next inner都是指放到其父节点下
      			if(targetNode.isParent == false)
 				{
 					parentNode = targetNode.getParentNode();
 	 			}
 	 			else
 	 			{
 	 				if(moveType == "prev" || moveType == "next")	//如果拖到节点的前面或后面，则表示要放到上一层目录
      				{
      					parentNode = targetNode.getParentNode();
      				}
      				else
      				{
	      				parentNode = targetNode;
      				}
 	 			}
      		}
      		else
      		{
      			showErrorMessage("targetNode is null,理论上不该出现");
      			return;
      		}
			
			var vid = gReposId;
 	 		
 	 		//确定是copy还是move,如果是move调用后台move操作，否则调用后台copy操作
	      	if(isCopy == true) //copy: 复制文件，并新建doc记录
	      	{
				DocCopy.copyDocs(treeNodes,parentNode,vid);
	      	}
	      	else	//move: 移动文件，并修改doc的parenID和path
	      	{
	      		DocMove.moveDocs(treeNodes,parentNode,vid); 
	      	}
      }
      //Drag and Drop Implementation End
      
      //zTree API没有onChange事件定义啊，汗，大概就zTree发送变化时的处理函数
      function zTreeOnChange()
      {
       	console.log("zTreeOnChange");
      	//updateMenu();
      }
        
      //为了能够让外部接口能够调用zTree的callback，需要记录当前treeNode等变量
      function zTreeOnClick(event, treeId, treeNode) 
      {
          if (gDocId != treeNode.id)
          {
             if(gEdit)
             {
              	//exitEdit then getDoc
              	exitEdit(gDocId,treeNode.id);
             }
             else
             {              
              	getDoc(treeNode.id,false);
             }             
          }
      };
      
      //Double Click 对于文件应该是编辑，对于目录应该是打开

	//判断当前目录下名字为 name的Node是否已经存在，parentNode是null表示根目录
	function isNodeExist(name,parentNode)
	{
		var parentId = null;
		if(parentNode && parentNode.id) 
		{
			parentId =  parentNode.id;
		}
		
		var treeObj = $.fn.zTree.getZTreeObj("doctree");
		var nodes = treeObj.getNodesByParam("name", name, parentNode);
		for (var i=0,l=nodes.length; i<l; i++)
		{
			if(nodes[i].pId == parentId)
			{	
				//alert(name + " 已存在");
				return true;
			}
		}
		return false;
	}
	
	//get the treeNode under parentNode with name
	function getNodeByName(name,parentNode)
	{
		var parentId = null;
		if(parentNode && parentNode.id) 
		{
			parentId =  parentNode.id;
		}
		
		var treeObj = $.fn.zTree.getZTreeObj("doctree");
		var nodes = treeObj.getNodesByParam("name", name, parentNode);
		for (var i=0,l=nodes.length; i<l; i++)
		{
			if(nodes[i].pId == parentId)
			{	
				return nodes[i];
			}
		}
		return null;
	}
	
	//获取Node的路径
	function getNodePath(treeNode)
	{
		var remoteDir = gReposName+"::/";
		if(treeNode)
		{
			var nodes = treeNode.getPath();	//获取当前节点的所有父节
			console.log("getNodePath() nodes ",nodes);	
			for( var i = 0 ; i < nodes.length-1; i++ )
			{
				remoteDir += nodes[i].name + "/"; 
			}
			
			if(true == treeNode.isParent)
			{
				remoteDir += treeNode.name + "/";
			}
			else
			{
				remoteDir += treeNode.name;				
			}
		}
		return remoteDir;
	}

	//Rename and Delete Implemenation Start: confirm rename operation
	var isCanceled = 0; //定义这个全局变量是因为OnRename有个bug,isCancel的状态不对
	function zTreeBeforeRename(treeId, treeNode, newName, isCancel) {
		if(isCancel == true)
		{
			//alert("isCancel");
			return true;
		}
		
		//文件同名表示放弃修改
		var treeObj = $.fn.zTree.getZTreeObj("doctree");
		if(treeNode.name == newName)
		{
			//alert("名字未修改");
			isCanceled = 1;
			treeObj.cancelEditName();
			return false;
		}
			
		//检查同名文件是否已存在
		var parentNode = treeNode.getParentNode();
		if(isNodeExist(newName,parentNode) == true)
		{
			bootstrapQ.alert(newName + " 已存在！");
			isCanceled = 1;
			treeObj.cancelEditName();
			return false;
		}
		
		//确认是否修改
		if(confirm("确定修改?") == false)
		{
			isCanceled = 1;
			treeObj.cancelEditName();
			return false;
		}
		else
		{
			isCanceled = 0;
			return true;
		}
	}
    function zTreeOnRename(event, treeId, treeNode, isCancel) {
        console.log("zTreeOnRename()");
        if(isCanceled == 1)
        {
        	//alert("取消修改");
           	return;
        }
        
        renameDoc(treeNode.id,treeNode.name);
    }
    
	/* I will call doDelete to delete treeNodes
	function zTreeBeforeRemove(treeId, treeNode) {	
		if(treeNode)
		{
			if(treeNode.isParent == true)
			{
				return confirm("警告：是否删除整个目录，请确认？");			
			}
			else
			{
				return confirm("是否删除文件");		
			}
		}
		return false;
	}
	
    function zTreeOnRemove(event, treeId, treeNode) {
    	console.log("zTreeOnRemove()");
    	var treeNodes = [];
    	treeNodes.push(treeNode);
		DocDelete.deleteDocs(treeNodes);
    }
	*/
	
    //Rename and Delete Implemenation End	

    //该接口是为了避免新增Node时触发的异步加载导致出现多个Node
	function addTreeNode(nodeName,isParent,nodeId,parentNode)
	{
		console.log("addTreeNode() nodeName:" + nodeName + " nodeId:" + nodeId + " parentNode",parentNode);
		
		//parentNode处于展开状态时，需要手动addTreeNode以保证与后台同步，否则只要触发异步加载即可
		if(parentNode == null || parentNode.open == true)
		{
			console.log("addTreeNode() parentNode is open");
			if(parentNode == null)
			{
				pId = 0;
			}
			else
			{
				pId = parentNode.id;
			}
			
			if(pId == 0)
			{
				pId = "root"; //zTree root id is root -__-!
			}
			console.log("addTreeNode() pId = " + pId);
			//add the treeNode
			var treeObj = $.fn.zTree.getZTreeObj("doctree");
      		var newNode = {name: nodeName, id : nodeId, isParent: isParent, pId: pId};
      		newNodes = treeObj.addNodes(parentNode, newNode);
		}
		else
		{
			console.log("addTreeNode() parentNode is close,do open it");

			//open the parentNode
			var treeObj = $.fn.zTree.getZTreeObj("doctree");
			treeObj.expandNode(parentNode, true, false, true);
		}
	}
	
	//zTree初始化接口:根据data和setting生成zTree
	function zTreeInit(data) {
	    console.log("zTreeInit");
	    //console.log(setting);
	
	    var doctree = zTree.init($("#doctree"), setting, data);
	    //doctree.expandAll(true); //考虑只自动展开根目录下目录
	}
	
	//PageInit
	function SysInit()
	{
		console.log("SysInit");
    	
    	//确定当前登录用户是否已登录
    	$.ajax({
            url : "/DocSystem/getLoginUser.do",
            type : "post",
            dataType : "json",
            data : {},
            success : function (ret) {
                if( "ok" == ret.status )
                {
                	var user = ret.data;
                	login_user = user;
                	//显示用户信息
                	ShowUserInfo(user);
                	
                	//Show ReposMenu
                	syncUpMenu(showDoc);
                }
                else 
                {
                    console.log(ret.msgInfo);
                }
            },
            error : function () {
            	showErrorMessage("服务器异常:获取用户信息失败");
            }
        });		
	}
	
	//将后台Menu,同步回前台
	function syncUpMenu(callback)
	{
		console.log("syncUpMenu");
	    getMenu(reDrawMenu,callback);
	}
	
	function reDrawMenu(data)
	{
		if( window.menu != data ){
	        console.log("同步菜单");
	        drawMenu(data);
	    }else{
	        console.log("重新绘制菜单，因为当前菜单数据与zTree不一致");
	        drawMenu(data);
	    }
	}
	
	//绘制zTree with the data:强制绘制，判断的东西不应该放在这里
	function drawMenu(data) {
		console.log("drawMenu");
		window.menu = data;
	    //data = JSON.parse('"' + data + '"'); //We need to use JSON parse one more time here  
	    //var menu = JSON.parse(data);
	    var menu = data;
	    //遍历jason_arry
      	for(var i=0; i<menu.length; i++)
      	{
           var jsonObj = menu[i];
           jsonObj.pId = jsonObj.pid != 0? jsonObj.pid : "root",
           jsonObj.isParent = jsonObj.type == 1? false: true;
       }
	   //console.log(menu);
	   zTreeInit(menu);
	   drawSecondMenu(menu);
	}
	function drawSecondMenu(data){
 	 	var str="";
       	for(var i=0; i<data.length; i++)
 	      	{
 	           var iconType =menu[i].type===2?'<i class="type2 icons"></i>':'<i class="type1 icons"></i>';
 	           str+='<li onclick="secondGetDoc(this)" dataId='+data[i].id+' datatype='+data[i].type+' class="second-listBox"><div class="filename pull-left">'+iconType+menu[i].name+'</div><div class="filedate pull-right">'+formatDate(menu[i].createTime)+'</div><div class="handle pull-right"><i class="glyphicon glyphicon-new-window" onclick="fx(this,event)"></i><i class="glyphicon glyphicon-download-alt" onclick="xz(this,event)"></i><i onclick="sc(this,event)" class="glyphicon glyphicon-trash"></i></div></li>';
 	       }
       	$("#secondList").html(str);
 	}
 	function secondGetDoc(obj){
 		var id = $(obj).attr('dataId');
 		var type = $(obj).attr('dataType')
 		console.log(type);
 		if(type==1)getDoc(id,false);
 		else{
 			alert("获取文件夹内容")
 		}
 	}
 	function fx(obj,event){
 		var id = $(obj).parents('li').attr('dataId');
 		alert('分享'+id);
 		event.stopPropagation();
 	}
 	function xz(obj,event){
 		var id = $(obj).parents('li').attr('dataId');
 		
 		alert('下载'+id);
 		event.stopPropagation();
 	}
 	function sc(obj,event){
 		var id = $(obj).parents('li').attr('dataId');
 		alert('删除'+id);
 		event.stopPropagation();
 	}
 	function formatDate(date) {
 		var now = new Date(date);
 		var year=now.getFullYear(); 
 		var month=now.getMonth()+1; 
 		var date=now.getDate(); 
 		return year+"-"+month+"-"+date; 
 	} 
	function showDoc()
	{
		console.log("showDoc gDocId:" + gDocId);
		if(gDocId)
		{
			//select the zTreeNode with gDocId
			 var zTree = $.fn.zTree.getZTreeObj("doctree");
			 var node = zTree.getNodeByParam("id",gDocId);
			 zTree.selectNode(node);
			
			//获取DocContent
	   		getDoc(gDocId,gEdit);
	   	}             
	}
	
	function previewDoc()
	{
		console.log("previewDoc gDocId:" + gDocId);
		if(gDocId)
		{
		    var docId = gDocId;
			//Convert doc to PDF and return the link, then show the pdf 
		    $.ajax({
		        url : "/DocSystem/Doc/DocToPDF.do",
		        type : "post",
		        dataType : "json",
		        data : {
		            docId : docId,
		        },
		        success : function (ret) {
		            if( "ok" == ret.status ){
		                var fileLink = ret.data;
		                console.log("fileLink" + fileLink);
		    			//在新的页面打开
		    			window.open("/DocSystem/web/viewDoc.html?fileLink=" + fileLink); 
		            }
		            else
		            {
		            	showErrorMessage("文件预览失败：" + ret.msgInfo);              	
		            }
		        },
		        error : function () {
		            showErrorMessage("文件预览失败：服务器异常");
		        }
		    });
	   	}
		else
		{
			showErrorMessage("请选择需要预览的文件"); 
		}
	}
	
	function WikiEditBtnCtrl(edit)
	{
		 if(edit)
	   	 {
	      	$("#btnExitEdit").show();
	      	$("#btnSaveWiki").show();  
	      	$("#btnEditWiki").hide();
	      	$("#btnViewDoc").hide();
	     }
	     else
	     {
		    $("#btnExitEdit").hide();
	      	$("#btnSaveWiki").hide(); 
	      	$("#btnEditWiki").show();
	      	$("#btnViewDoc").show();
	     }
	}
	/************************** contextMenu 接口***************************/	
	//add a new Doc: type 1: 文件  2:目录
    function newDoc(type) {         
		//计算 ParentNode parentId remoteDir
  		//if curentRightClickedTreeNode is not parent node, set the newNode's parent to curentRightClickedTreeNode's parent node
		var parentNode = curRightClickedTreeNode;
		var parentId = 0;
		if(curRightClickedTreeNode && curRightClickedTreeNode.isParent === false)
		{
			parentNode = curRightClickedTreeNode.getParentNode();
		}
		if(parentNode && parentNode.id)
		{
			parentId = parentNode.id;
		}
		var remoteDir = getNodePath(parentNode); //only for display
        
        //对话框 title
        var title = "新建文件";
        if(type == 2)
        {
        	title = "新建目录";
        }
          
        //显示新建对话框
        qiao.bs.dialog({
              id: "dialog-new-doc",
              url: '#new-doc',
              title: title,
              okbtn: "确定",
              qubtn: "取消",
              callback: function () {
                      $("#dialog-new-doc input[name='name']").focus();
                      $("#dialog-new-doc input[name='remoteDir']").val(remoteDir);                
              }
        },function () {

              var name = $("#dialog-new-doc input[name='name']").val();
              var content = $("#dialog-new-doc input[name='content']").val();
			  //检查当前目录下是否有同名文件
			  if(isNodeExist(name,parentNode) == true)
			  {	
				showErrorMessage(name + " 已存在");
			  	return false;
			  }
			  var vid = gReposId;
			  
			  //发送新建文件请求到后台
              if( name ){
            	  if(content && content != "")
            	  {
            		  content = "#" + content; 
            	  }
                  addDoc(name,type,content,parentNode,parentId,vid);
                  return true;
              }else{
              	  alert("文件名不能为空");
                  return false;
              }
          });
   	}
	
	//目录列表区域拖放功能：预览区和子目录区域需要一起变化
    var oDiv=document.getElementById('line');
    oDiv.onmousedown=function(ev){
      var disX=ev.clientX-oDiv.offsetLeft;
      var disY=ev.clientY-oDiv.offsetTop;

      document.onmousemove=function(ev){
          var l=ev.clientX-disX;	//计算Line的位置
          oDiv.style.left=l+'px';	//设置Line的位置
     	  $(".manual-left")[0].style.width=ev.clientX+'px';
       	 $(".manual-right")[0].style.left=$(".second-table").width()+3+ev.clientX+'px';
       	 $(".second-table").css("left",$(".manual-left").width()+$("#line").width());
       	 $(".second-line").css("left",$(".manual-left").width()+$(".second-table").width()+$("#line").width());
   	  };
      
      document.onmouseup=function(ev){
   	  	//$(".manual-left")[0].style.width=ev.clientX+'px';
   	 	//$(".manual-right")[0].style.left=ev.clientX+'px';
   	 	document.onmousemove=null;
   	  	document.onmouseup=null;
      };
    };
    
    var oDiv2=document.getElementById('second-line');
    oDiv2.onmousedown=function(ev){
        var disX=ev.clientX-oDiv2.offsetLeft;
        var disY=ev.clientY-oDiv2.offsetTop;
   
       document.onmousemove=function(ev){
       		var l=ev.clientX-disX;	//计算Line的位置
           oDiv2.style.left=l+'px';	//设置Line的位置
           $('.second-table').width($(".second-line").position().left-$('.manual-left').width());
           $(".manual-right").css("left",$(".second-table").width()+$('.manual-left').width()+3);
           return false;
   	  };
    	  document.onmouseup=function(ev){
    	 	document.onmousemove=null;
    	  	document.onmouseup=null;
        };
    };
    //页面加载完成处理函数    
    $(document).ready(function(){
    	//初始化全局变量
    	gReposId = getQueryString("vid");
		gDocId = getQueryString("doc");
		gEdit = getQueryString("edit");
		if(!gEdit)
		{
			gEdit = false;
		}
    	console.log("ready() gDocId:"+gDocId +  " gReposId:" + gReposId + " gEdit:" + gEdit);
    	//处于编辑状态下，需要禁用删除和改名等所有编辑操作，避免出错
        if( gEdit ){
            var edit = {};
            setting.edit = edit;
        }
        //设置异步加载的参数
        var async =  {  
    		enable : true,//设置 zTree 是否开启异步加载模式  
            url : "/DocSystem/Repos/getSubDocList.do",
            type : "post",
    		autoParam : ["id"],//异步加载时需要自动提交父节点属性的参数  
    		otherParam:{"vid":gReposId},
    		dataFilter: asyncDataFilter, 
		};
		setting.async = async;
        
    	
    	//拖拽上传:目录树区域
    	var uuz = document.getElementById("uuz");  
    	uuz.ondragenter = function(e){  
            e.preventDefault();  
        };  
        uuz.ondragover = function(e){  
            e.preventDefault();
            //判断现在所在的zTree Node并选中它
            if(e.target.tagName=="SPAN"){
            	e.target.parentNode.click();
            }
        };  
        uuz.ondrop = function(e){   
            e.preventDefault();
            dragUploadConfirm(e);
        };
        //文件预览区的拖拽上传
        var doc =  document.getElementById("doc");  
        doc.ondragenter = function(e){  
            e.preventDefault();  
        };  
        doc.ondragover = function(e){  
            e.preventDefault();  
        };  
        doc.ondrop = function(e){   
            e.preventDefault();
            dragUploadConfirm(e);
        };

		//set the vid in upload form
		$("#reposId").val(gReposId);
        
		//获取仓库信息
		getReposInfo(SysInit);
		
		//右键菜单实现：contextMenu Start
		context.init({preventDoubleContext: true});
		
		//zTree外部的右键菜单
		context.attach('#treeBody', [
			{text: '新建', subMenu: [
				{text: '文件',  action: function(e){
						e.preventDefault();
						curRightClickedTreeNode = null; 
	        			newDoc(1);
					}
				},
				{text: '文件夹',  action: function(e){
						e.preventDefault();
	        			curRightClickedTreeNode = null;
	        			newDoc(2);
					}
				},
				]
			},
			{text: '上传', subMenu: [
				{text: '文件',  action: function(e){
						e.preventDefault();
						curRightClickedTreeNode = null; 
	        			uploadFiles();
					}
				},
				{text: '文件夹',  action: function(e){
						e.preventDefault();
						curRightClickedTreeNode = null; 
						uploadDir();
					}
				},	
				]
			},
			{divider: true},
			{text: '粘贴', action: function(e){
						e.preventDefault();
						curRightClickedTreeNode = null; 
						DoPaste(gCopiedNodes,null);
					}
			},
			{divider: true},
			{text: '其它', subMenu: [
						{text: '查看仓库历史', action: function(e){
									e.preventDefault();
									curRightClickedTreeNode = null; 
				        			showDocHistory();
								}
						},
   				]
   			},
			]
		);
		//zTree上的右键菜单
		context.attach('#tree', [
			{text: '新建', subMenu: [
				{text: '文件',  action: function(e){
						e.preventDefault();
	        			newDoc(1);
					}
				},
				{text: '文件夹',  action: function(e){
						e.preventDefault();
	        			newDoc(2);
					}
				},
				]
			},
			{text: '上传', subMenu: [
				{text: '文件',  action: function(e){
						e.preventDefault();
	        			uploadFiles();
					}
				},
				{text: '文件夹',  action: function(e){
						e.preventDefault();
	        			uploadDir();
					}
				},	
				]
			},
			{divider: true},
			{text: '复制', action: function(e){
						e.preventDefault();
						gCopiedNodes = getCopiedNodes();
						console.log("gCopiedNodes",gCopiedNodes);
					}
			},
			{text: '粘贴', action: function(e){
						e.preventDefault();
						var parentNode = curRightClickedTreeNode;
						if(curRightClickedTreeNode && curRightClickedTreeNode.isParent === false)
						{
							parentNode = curRightClickedTreeNode.getParentNode();
						}
						DoPaste(gCopiedNodes,parentNode);
					}
			},
			{divider: true},
			{text: '重命名', action: function(e){
						e.preventDefault();
						 var treeObj = $.fn.zTree.getZTreeObj("doctree");
						if(curRightClickedTreeNode !== null)
						{
							treeObj.editName(curRightClickedTreeNode);
							curRightClickedTreeNode = null;
	        			}
					}
			},
			{text: '删除', action: function(e){
						e.preventDefault();
						var treeObj = $.fn.zTree.getZTreeObj("doctree");
						var deleteNodes = getDeleteNodes();
						DoDelete(deleteNodes);
					}
			},
			{divider: true},
			{text: '下载', action: function(e){
						e.preventDefault();
	        			download();
					}
			},
			{divider: true},
			{text: '其它', subMenu: [
			           	{text: '复制名字', action: function(e){
									e.preventDefault();
				        			copyDocName();
								}
						},
						{text: '复制路径', action: function(e){
									e.preventDefault();
				        			copyDocPath();
								}
						},
						{text: '复制链接', action: function(e){
									e.preventDefault();
				        			copyUrl();
								}
						},	
						{divider: true},
						{text: '查看历史', action: function(e){
									e.preventDefault();
				        			showDocHistory();
								}
						},
   				]
   			},
		]);
		
		context.settings({compress: true});
		
		$(document).on('mouseover', '.me-codesta', function(){
		$('.finale h1:first').css({opacity:0});
		$('.finale h1:last').css({opacity:1});
		});
	
		$(document).on('mouseout', '.me-codesta', function(){
			$('.finale h1:last').css({opacity:0});
			$('.finale h1:first').css({opacity:1});
		});
		//右键菜单实现：contextMenu End
    });
</SCRIPT>

</body>
</html>
